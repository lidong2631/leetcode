java xml

DOM Stands for Document Object Model and it represent an XML Document into tree format which each element representing tree branches. 

DOM Parser creates an In Memory tree representation of XML file and then parses it, so it requires more memory and 

its advisable to have increased heap size for DOM parser in order to avoid Java.lang.OutOfMemoryError:java heap space . 

Parsing XML file using DOM parser is quite fast if XML file is small but if you try to read a large XML file using DOM parser 

there is more chances that it will take a long time or even may not be able to load it completely simply because it requires lot of memory 

to create XML Dom Tree. Java provides support DOM Parsing and you can parse XML files in Java using DOM parser. 

DOM classes are in w3c.dom package while DOM Parser for Java is in JAXP (Java API for XML Parsing) package.



SAX XML Parser in Java

SAX Stands for Simple API for XML Parsing. This is an event based XML Parsing and it parse XML file step by step so much suitable for 

large XML Files. SAX XML Parser fires event when it encountered opening tag, element or attribute and the parsing works accordingly. 

It’s recommended to use SAX XML parser for parsing large xml files in Java because it does not require to load whole XML file in Java 

and it can read a big XML file in small parts. Java provides support for SAX parser and you can parse any xml file in Java using SAX Parser, 

I have covered example of reading xml file using SAX Parser here. One disadvantage of using SAX Parser in java is that reading XML file 

in Java using SAX Parser requires more code in comparison of DOM Parser.



Difference between DOM and SAX XML Parser

Here are few high level differences between DOM parser and SAX Parser in Java:

1) DOM parser loads whole xml document in memory while SAX only loads small part of XML file in memory.

2) DOM parser is faster than SAX because it access whole XML document in memory.

3) SAX parser in Java is better suitable for large XML file than DOM Parser because it does not require much memory.

4) DOM parser works on Document Object Model while SAX is an event based xml parser.


That’s all on difference between SAX and DOM parsers in Java, now it’s up to you on which XML parser you going to choose. I recommend use DOM parser over SAX parser if XML file is small enough and go with SAX parser if you don’t know size of xml files to be processed or they are large.


Read more: http://javarevisited.blogspot.com/2011/12/difference-between-dom-and-sax-parsers.html#ixzz3EXlEJkdO





DOM:

package com.mkyong.core;
 
import java.io.File;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
 
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
 
public class WriteXMLFile {
 
    public static void main(String argv[]) {
 
      try {
 
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
 
        // root elements
        Document doc = docBuilder.newDocument();
        Element rootElement = doc.createElement("company");
        doc.appendChild(rootElement);
 
        // staff elements
        Element staff = doc.createElement("Staff");
        rootElement.appendChild(staff);
 
        // set attribute to staff element
        Attr attr = doc.createAttribute("id");
        attr.setValue("1");
        staff.setAttributeNode(attr);
 
        // shorten way
        // staff.setAttribute("id", "1");
 
        // firstname elements
        Element firstname = doc.createElement("firstname");
        firstname.appendChild(doc.createTextNode("yong"));
        staff.appendChild(firstname);
 
        // lastname elements
        Element lastname = doc.createElement("lastname");
        lastname.appendChild(doc.createTextNode("mook kim"));
        staff.appendChild(lastname);
 
        // nickname elements
        Element nickname = doc.createElement("nickname");
        nickname.appendChild(doc.createTextNode("mkyong"));
        staff.appendChild(nickname);
 
        // salary elements
        Element salary = doc.createElement("salary");
        salary.appendChild(doc.createTextNode("100000"));
        staff.appendChild(salary);
 
        // write the content into xml file
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(new File("C:\\file.xml"));
 
        // Output to console for testing
        // StreamResult result = new StreamResult(System.out);
 
        transformer.transform(source, result);
 
        System.out.println("File saved!");
 
      } catch (ParserConfigurationException pce) {
        pce.printStackTrace();
      } catch (TransformerException tfe) {
        tfe.printStackTrace();
      }
    }
}




import javax.xml.validation

// parse an XML document into a DOM tree
    DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
    Document document = parser.parse(new File("instance.xml"));

    // create a SchemaFactory capable of understanding WXS schemas
    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

    // load a WXS schema, represented by a Schema instance
    Source schemaFile = new StreamSource(new File("mySchema.xsd"));
    Schema schema = factory.newSchema(schemaFile);

    // create a Validator instance, which can be used to validate an instance document
    Validator validator = schema.newValidator();

    // validate the DOM tree
    try {
        validator.validate(new DOMSource(document));
    } catch (SAXException e) {
        // instance document is invalid!
    }



