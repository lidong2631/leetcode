1 - 100
median of two sorted arrays
zigzag conversion
regular expression matching
4Sum
divide two integers
substring with concatenation of all words
multiply strings
wildcard matching
rotate image
permutation sequence
text justification
edit distance
minimum window substring
scramble string


LinkedList:
create dummy node. get prev and next and perform reverse subroutine
Swap Nodes in Pairs
Reverse Nodes in k-Group
Reverse Linked List II

connect two list (careful need to set next to null when connect)
Partition List

two pointers separated by a distance (careful if distance is larger than linkedlist length need to mod)
to calculate LinkedList length use
int len = 1;
while (p.next != null) {
	len++;
	p = p.next;
}
Remove Nth Nodes From End of List
Rotate List



Remove Duplicate
two pointers when (elements not same or find target) set left pointer and move ahead
Remove Duplicates from Sorted Array
Remove Duplicates from Sorted List
Remove Element

Remove Duplicates from Sorted Array II

Remove Duplicates from Sorted List II



NP:
Letter Combinations of a Phone Number (helper(digits, map, 0, "", res)  HashMap)

|--Combinations 		(helper(res, n, k, 1, new ArrayList<Integer>()))
|
|--Combination Sum 	(helper(candidates, target, 0, new ArrayList<Integer>(), res))
|--Combination Sum II 	(helper(candidates, target, 0, new ArrayList<Integer>(), res))
|
|--Permutations 		(helper(nums, used, new ArrayList<Integer>(), res))
|--Permutations II 	(i > 0 && nums[i] == nums[i-1] && !used[i-1] continue)

if Valid go to next row/col
N-QUeens 			(helper(res, n, 0, colForRow), colForRow, isValid)
N-Queens II
Sudoku Solver 		(helper(board, 0, 0))

Subsets 		(List<List<Integer>> helper(S, S.length-1))
Subsets II 		(List<List<Integer>> helper(S, S.length-1, last))

Restore IP Address 	(helper(s, 0, 1, "", res))





101 - 200
Binary Tree Upside Down
Maximum Gap


if (left == null && right == null) return true;
if (left == null || right == null) return false;
if (left.val == right.val && helper(...)) return true;	
return false;
Same Tree
Symmetric Tree


Binary Tree Level Order Traversal
Binary Tree Zigzag Level Order Traversal
Binary Tree Level Order Traversal II


Converted Sorted Array to Binary Search Tree
Converted Sorted List to Binary Search Tree

Maximum Depth of Binary Tree
Minimum Depth of Binary Tree

if (root == null) ...
if (root.left == null && root.right == null && sum == root.val OR sum == 0) ...
Path Sum
Path Sum II
Sum Root to Leaf Numbers


one dimension Array/List to store information, second for loop from last to first
Pascal Triangle II
Triangle


Binary Tree Maximum Path Sum
Balanced Binary Tree


for (int i = 1; i < s.length(); i++) 
	for (int j = 0; j <= i; j++)
Palindrome Partitioning II
Word Break


Palindrome Partitioning 	(helper(s, getDict(s), 0, new ArrayList<String>(), res))
Word Break II 				(helper(s, wordDict, 0, "", res);)


(1) fast != null && fast.next != null VS (2) fast.next != null && fast.next.next != null
if you need to separate list into two use (2) if you need to find cycle use (1)
(1) Linked List Cycle
(1) Linked List Cycle II
(2) Reorder List  (use reverse linkedlist)
(2) Sort List 	(use merge 2 sorted list)


Reverse Words in a String (same as Length of Last Word)





201 - 300
Shortest Palindrome
The Skyline Problem
Basic Calculator
Verify Preorder Sequence in Binary Search Tree
Paint House II
Alien Dictionary
Closest Binary Search Tree Value II
Expression Add Operators



Isomorphic Strings
Word Pattern


Kth Largest Element in an Array (not same as k-sliding window !)


review all the backtracking problems
Combination Sum III (helper(num, k, n, 0, new ArrayList<Integer>(), res))


while (i < nums.length) {
	if (set.contains(nums[i])) return true;
	else set.add(nums[i++]);
	if (i - j > k) set.remove(nums[j++]);
}
Contains Duplicate II
Contains Duplicate III
(k-sliding-window) first insert k elements in a set then update it for the rest n-k elements
Sliding Window Maximum


private int getLeftHeight(TreeNode root) {
    int height = 0;
    while (root != null) {
        root = root.left;
        height++;
    }
    return height;
}
calculate tree height
Count Complete Tree Nodes


low = n % factor;
curr = (int)(n / factor % 10);
high = n / (factor * 10)
Number of Digit One


Shortest Word Distance
Shortest Word Distance III


bottom up
Count Univalue Subtrees (Binary Tree Max Sum)


Factor Combination (helper(n/i, i, list, res))
Combination Sum III (helper(k, n-i, i+1, list, res))


if (root == null) ...
if (root.left == null && root.right == null && sum == 0) ...
if (root.left != null) ...
if (root.right != null) ...
Binary Tree Paths (only has 2 3 4, remember pathStr)
Path Sum II


int fac = 1;
while (num / fac >= 10) fac *= 10;
while (num != 0) {
	tmp += num / fac;
	num %= fac;
	fac /= 10;
}
num = tmp; tmp = 0;
Add Digits
Happy Number


Arrays.sort(nums);
for (int i = nums.length - 1; i >= 2; i--) {
	// while (left < right) (if nums[left] + nums[right] + nums[i] < target) count+=right-left; left++; else right--;
	// call 2sum subroutine
	// call 2sum Closest
}
3Sum Smaller


Single Number III (diff &= ~(diff - 1))


int x = find(parent, edges[i][0]), y = find(parent, edges[i][1]);
if (x == y) return false;
parent[x] = y;

int find(int[] parent, int i) {
	if (parent[i] == -1) return i;
	return find(parent, parent[i]);
}
Graph Valid Tree


create Map<Character, Integer>
add half number of all chars into a list
helper(list, mid, new StringBuffer(), new boolean[list.size()], res) (use Permutaion subroutine)
Palindrome Permutation


for (int i = 0; i < nums.length; i++) {
	if (nums[i] < nums.length && nums[i] != nums[nums[i]]) {	// slightly difference
		int tmp = nums[nums[i]];
		nums[nums[i]] = nums[i];
		nums[i] = tmp;
		i--;
	}
}
Find the Duplicate Number
Missing Number
First Missing Positive (1-100)


Paint Fence (Count Numbers with Unique Digit)


Perfect Squares
Longest Increasing Subsequence


Flat 2D Vector

Deque<Iterator> list
Iterator i = list.removeFirst();
int tmp = (int)i.next();
if (i.hasNext()) list.addLast(i);	// idea like implements Stack using Queue
Zigzag Iterator

hasPeeked / peekElement
peek() {
	if (!hasPeeked) set peekElement / hasPeeked
	return peekElement
}
next() {
	if (hasPeeked) set tmp / peekElement / hasPeeked return tmp
	return i.next()
}
Peeking Iterator

Binary Search Tree Iterator


// when node has no right subtree
while (root != null) {
	if (root.val > p.val) successor = root; root = root.left;
	else root = root.right;
}
Inorder Successor in BST




301 - 400
Number of Islands II
Additive Number
Range Sum Query - Mutable
Range Sum Query 2D - Mutable
Best Time to Buy and Sell Stock with Cooldown
Sparse Matrix Multiplication
Burst Balloons
Shortest Distance from All Buildings
Create Maximum Number
Wiggle Sort II
Verify Preorder Serialization of a Binary Tree
Self Crossing
Rearrange Strin k Distance Apart
Max Sum of Rectangle No Larger Than K


bottom up
House Robber III (Count Univalue Subtrees, Binary Tree Max Sum, Balanced Tree)


Counting Bits (Grey Code)


Flatten Nested List Iterator (Flat 2D Vector/Zigzag Iterator/Peeking Iterator/Binary Search Tree Iterator)


Top K Frequent Elements (Kth Largest Element in Array)


Nested List Weight Sum
Nested List Weight Sum II


bottom up
Find Leaves of Binary Tree (Binary Tree Level Order Traversal)


Combination Sum IV(Longest Increasing Subsequence review I II III)


Kth Smallest Element in a Sorted Matrix
Find K Pairs with Smallest Sums