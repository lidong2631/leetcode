1 - 100
4Sum
divide two integers
substring with concatenation of all words
multiply strings
rotate image
permutation sequence
text justification
edit distance
minimum window substring
scramble string



Add Two Number (left to right)
Plus One (left to right)
Plus One Linked List (right to left)


left = i - (len-1)/2; right = i + len/2
int getPalindromeLength(String str, int left, int right)
    while (left >=0 && right <= str.length()-1 && str.charAt(left) == str.charAt(right))
        left++; right--;
    return right - left - 1;
Longest Palindromic Substring


while num != 0
    num = 10*res + num%10;
    num/=10;
Reverse Integer     (to get last digit of number use num % 10)
if x / radix != x % 10 return false
x = (x % radix) / 10;
Palindrom Number (to get first digit of number use num / radix, to cut first digit use num % radix, to cut last digit num / 10)


String to Integer(atoi) (Valid Number)


boolean[][] dp = new boolean[p.length()+1][s.length()+1]; dp[0][0] = true;
for (int i = 0; i < p.length(); i++) if (p.charAt(i) == '*' && dp[0][i-1]) dp[0][i] = true;
for i - s.length()
    for j - p.length()
        if p.charAt(j) == s.charAt(i) || p.charAt(j) == '.'
        if p.charAt(j) == '*'
            if p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.' dp[i+1][j+1] = dp[i+1][j-1]
            else dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1]
Regular Expression Matching
dp[0][0] = true;
for (int i = 0; i < p.length(); i++)
    if (p.charAt(i) != '*')
        for (int j = 0; j < s.length(); j++) dp[i+1][j+1] = dp[i][j] && (p.charAt(i) == s.charAt(j) || p.charAt(i) == '?')
    else k = 0; while (k <= s.length() && !dp[i][k++])
        while (k <= s.length()) dp[i+1][k++] = true;
Wildcard Matching


String[] roman = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
int[] n = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
for i - n
    while num >= n[i]
        num -= n[i]; sb.append(roman[i])
Integer to Roman
map.put(IVXLCDM 1 5 10 50 100 500 1000)
for c : s.toCharArray()
    int curr = map.get(c); res += (curr>prev)?curr-2*prev:curr; prev = curr;
Roman to Integer


while (i > 0 && nums[i-1] >= nums[i]) i--;
int j = i - 1;
while (i < nums.length && nums[i] > nums[j]) i++;
swap(nums, i-1, j);
reverse(nums, j+1);
Next Permutation


if stack.isEmpty() && s.charAt(i) == ')' j = i + 1;
else if s.charAt(i) == '(' stack.push(i);
else stack.pop();
    if stack.isEmpty() maxLen = Math.max(maxLen, i-j+1);
    else maxLen = Math.max(maxLen, i-stack.peek())  
Longest Valid Parentheses


while (left <= right)
    if (nums[mid] == target)
    else if (nums[mid] <= nums[right]) checkv right
    else check left
Search in Rotated Sorted Array I II


for i = 2; i <= n; i++
    for j = 1; j < str.length(); j++
        if (str.charAt(j) == str.charAt(j-1)) count++;
        else
    res.append(count);
    res.append();
    str = res.toString();
Count and Say


if n == 0 return 1.0
double half = pow(x, n/2);
if n % 2 == 0 return half * half;
else if n > 0 return half * half * x;
else return half * half / x;
Pow(x, n)


LinkedList:
create dummy node. get prev and next and perform reverse subroutine
Swap Nodes in Pairs
Reverse Nodes in k-Group
Reverse Linked List II

connect two list (careful need to set next to null when connect)
Partition List

two pointers separated by a distance (careful if distance is larger than linkedlist length need to mod)
to calculate LinkedList length use
int len = 1;
while (p.next != null) {
	len++;
	p = p.next;
}
Remove Nth Nodes From End of List
Rotate List



Remove Duplicate (Move Zeroes  i j both start from 0)
two pointers when (elements not same or find target) set left pointer and move ahead
Remove Duplicates from Sorted Array
Remove Duplicates from Sorted List
Remove Element

Remove Duplicates from Sorted Array II

Remove Duplicates from Sorted List II



NP:
Letter Combinations of a Phone Number (helper(digits, map, 0, "", res)  HashMap)

|--Combinations 		(helper(res, n, k, 1, new ArrayList<Integer>()))
|
|--Combination Sum 	(helper(candidates, target, 0, new ArrayList<Integer>(), res))
|--Combination Sum II 	(helper(candidates, target, 0, new ArrayList<Integer>(), res))
|
|--Permutations 		(helper(nums, used, new ArrayList<Integer>(), res))
|--Permutations II 	(i > 0 && nums[i] == nums[i-1] && !used[i-1] continue)

if Valid go to next row/col
N-QUeens 			(helper(res, n, 0, colForRow), colForRow, isValid)
N-Queens II

if (r == 0)
if (c == 9)
if (board[r][c] == '.')
else return helper(board, r, c+1)
return false;
Sudoku Solver 		(boolean helper(board, 0, 0))

Subsets 		(List<List<Integer>> helper(S, S.length-1))
Subsets II 		(List<List<Integer>> helper(S, S.length-1, last))

Restore IP Address 	(helper(s, 0, 1, "", res))





101 - 200
Binary Tree Upside Down
Maximum Gap


if (left == null && right == null) return true;
if (left == null || right == null) return false;
if (left.val == right.val && helper(...)) return true;	
return false;
Same Tree
Symmetric Tree


Binary Tree Level Order Traversal
Binary Tree Zigzag Level Order Traversal
Binary Tree Level Order Traversal II


Converted Sorted Array to Binary Search Tree
Converted Sorted List to Binary Search Tree

Maximum Depth of Binary Tree
Minimum Depth of Binary Tree

if (root == null) ...
if (root.left == null && root.right == null && sum == root.val OR sum == 0) ...
Path Sum
Path Sum II
Sum Root to Leaf Numbers


one dimension Array/List to store information, second for loop from last to first
Pascal Triangle II
Triangle


Binary Tree Maximum Path Sum
Balanced Binary Tree


for (int i = 1; i < s.length(); i++) 
	for (int j = 0; j <= i; j++)
Palindrome Partitioning II
Word Break


Palindrome Partitioning 	(helper(s, getDict(s), 0, new ArrayList<String>(), res))
Word Break II 				(helper(s, wordDict, 0, "", res);)


(1) fast != null && fast.next != null VS (2) fast.next != null && fast.next.next != null
if you need to separate list into two use (2) if you need to find cycle use (1)
(1) Linked List Cycle
(1) Linked List Cycle II
(2) Reorder List  (use reverse linkedlist)
(2) Sort List 	(use merge 2 sorted list)


Reverse Words in a String (same as Length of Last Word)





201 - 300
Shortest Palindrome
The Skyline Problem
Basic Calculator
Verify Preorder Sequence in Binary Search Tree
Paint House II
Alien Dictionary
Closest Binary Search Tree Value II
Expression Add Operators
Word Pattern II



Kth Largest Element in an Array (not same as k-sliding window !)


review all the backtracking problems
Combination Sum III (helper(num, k, n, 0, new ArrayList<Integer>(), res))


while (i < nums.length) {
	if (set.contains(nums[i])) return true;
	else set.add(nums[i++]);
	if (i - j > k) set.remove(nums[j++]);
}
Contains Duplicate II
Contains Duplicate III
(k-sliding-window) first insert k elements in a set then update it for the rest n-k elements
Sliding Window Maximum


private int getLeftHeight(TreeNode root) {
    int height = 0;
    while (root != null) {
        root = root.left;
        height++;
    }
    return height;
}
calculate tree height
Count Complete Tree Nodes


low = n % factor;
curr = (int)(n / factor % 10);
high = n / (factor * 10)
Number of Digit One


if (p2 != -1) minLen = Math.min(minLen, i - p2);
p1 = i;
Shortest Word Distance
Shortest Word Distance III


helper(n, n)
Strobogrammatic Number ii


int offset = strings[i].charAt(0) - 'a';
for 
    char curr = (char)(strings[i].charAt(j) - offset);
    sb.append(curr);
Group Shifted Strings (Group Anagram)


boolean helper(root, res)
boolean l = helper(root.left, res); boolean r = helper(root.right, res);
if (l & r)
Count Univalue Subtrees (Binary Tree Max Sum )


sort by start time then create a heap that sort by end time. earlier end time is ahead
Interval curr = heap.poll();
if (curr.end <= intervals[i].start) curr.end = intervals[i].end;
else heap.offer(intervals[i]);
heap.offer(curr);
Meeting Rooms II


helper(n/i, i, list, res)
Factor Combination (helper(n, 2, new Arraylist<Integer>(), res))
Combination Sum III (helper(k, n-i, i+1, list, res))


if (root == null) ...
if (root.left == null && root.right == null && sum == 0) ...
if (root.left != null) ...
if (root.right != null) ...
Binary Tree Paths (only has 2 3 4, remember pathStr)
Path Sum II


int fac = 1;
while (num / fac >= 10) fac *= 10;
while (num != 0) {
	tmp += num / fac;
	num %= fac;
	fac /= 10;
}
num = tmp; tmp = 0;
Add Digits
Happy Number


Arrays.sort(nums);
for (int i = nums.length - 1; i >= 2; i--) {
	// while (left < right) (if nums[left] + nums[right] + nums[i] < target) count+=right-left; left++; else right--;
	// call 2sum subroutine
	// call 2sum Closest
}
3Sum Smaller


Single Number III (diff &= ~(diff - 1))


int x = find(parent, edges[i][0]), y = find(parent, edges[i][1]);
if (x == y) return false;
parent[x] = y;

int find(int[] parent, int i) {
	if (parent[i] == -1) return i;
	return find(parent, parent[i]);
}
Graph Valid Tree


create Map<Character, Integer>
add half number of all chars into a list
helper(list, mid, new StringBuffer(), new boolean[list.size()], res) (use Permutaion subroutine)
Palindrome Permutation


for (int i = 0; i < nums.length; i++) {
	if (nums[i] < nums.length && nums[i] != nums[nums[i]]) {	// slightly difference
		int tmp = nums[nums[i]];
		nums[nums[i]] = nums[i];
		nums[i] = tmp;
		i--;
	}
}
Find the Duplicate Number
Missing Number
First Missing Positive (1-100)


diffColor = (diffColor + sameColor) * (k-1);
sameColor = tmp;
Paint Fence (Count Numbers with Unique Digit)


if (sb.length() == 0) return false;
...
return i == str.length() + 1;
Word Pattern


if (s.startsWith("++", i))
Flip Game I II


if (minHeap.size() == maxHeap.size())
    maxHeap.offer(num);
    if (minHeap.size() != 0 && num > minHeap.peek())
else
Find Median From DataStream


i = -1, j = dis.length, left = 0, right = 0, d = 0;
while i != j
    if left < right
        d += left; left += dis[++i];
    else
        d += right; right += dis[--j];
Best Meeting Point


int[] res = new int[n+1];
for i = 1 i <= n
    for j = 1 j * j <= i
        min = Math.min(min, res[i-j*j]+1);
    res[i] = min;
Perfect Squares

int[] dp = new int[n];
for (int i = 0; i < n; i++) {
    dp[i] = 1;
    for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[i] + 1);
    }
    maxLen = Math.max(maxLen, dp[i]);
}
Longest Increasing Subsequence


TreeNode node = null;   // without right subtree
while (root != null)
    if (root.val > p.val) node = root; root = root.left;
    else root = root.right;
Inorder Successor in BST


List<Iterator<Integer>> list
Flatten 2D Vector

Deque<Iterator> list
Iterator i = list.removeFirst();
int tmp = (int)i.next();
if (i.hasNext()) list.addLast(i);	// idea like implements Stack using Queue
Zigzag Iterator

hasPeeked / peekElement / Iterator<Integer>
peek() {
	if (!hasPeeked) set peekElement / hasPeeked
	return peekElement
}
next() {
	if (hasPeeked) set tmp / peekElement / hasPeeked return tmp
	return i.next()
}
Peeking Iterator

Binary Search Tree Iterator


// when node has no right subtree
while (root != null) {
	if (root.val > p.val) successor = root; root = root.left;
	else root = root.right;
}
Inorder Successor in BST


for (Character c : pattern.toCharArray()) {
    // get string separated by space
    if (sb.toString() == 0) return false;
    if (map1.containsKey(c)) {
        if (!map1.get(c).equals(tmp)) return false;
    }
    if (map2.containsKey(tmp)) {
        if (map2.get(tmp) != c) return false;
    }
    map1.put(c, tmp);
    map2.put(tmp, c);
}
return i == str.length() + 1;
Word Pattern
Isomorphic Strings (easier)


Binary Tree Longest Consecutive Sequence (Balanced Binary Tree / Binary Tree Max Sum)




301 - 400
Additive Number
Range Sum Query - Mutable
Range Sum Query 2D - Mutable
Best Time to Buy and Sell Stock with Cooldown
Burst Balloons
Shortest Distance from All Buildings
Create Maximum Number
Wiggle Sort II
Verify Preorder Serialization of a Binary Tree
Largest BST Subtree
Self Crossing
Rearrange Strin k Distance Apart
Max Sum of Rectangle No Larger Than K


BFS
Queue<String>
Set<String>
while (!queue.isEmpty()) {
    // every time remove a parentheses and if it is valid add to queue
}
boolean isValid(String s) {
    int count = 0;
    for(int i=0; i<s.length(); i++) {
        if(s.charAt(i)=='(') count++;
        if(s.charAt(i)==')' && count--==0) return false;
    }
    return count==0;
}
Remove Invalid Parenthese


int maxX = 0, maxY = 0, minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
dfs(image, x, y);
return (maxX-minX+1) * (maxY-minY+1);
dfs() {
    image[x][y] = '0';
    dfs(image, x+1, y); dfs(image, x-1, y); dfs(image, x, y+1); dfs(image, x, y-1);
}
Smallest Rectangle Enclosing Black Pixels


Union Find
for (int[] pos : positions) {
    arr[index] = index;
    ...
    for (int[] move : moves) {
        // get new pos if it != -1 union and count--
    }
}
int find(int[] parent, int i)
Number of Islands II


create adjList and leaves
while (n > 2) {
    List<Integer> newLeaves = new ArrayList<>();
    n -= leaves.size();
    move leaves and add new leaves
    leaves = newLeaves;
}
Minimum Height Tree


Queue<TreeNode> queue = new LinkedList<>();
Map<Integer, List<Integer>> map = new HashMap<>();
Queue<Integer> index = new LinkedList<>();
queue.add(root); index.add(0);
int left = 0, right = 0;
while (!queue.isEmpty()) {
    if (map)
    if (curr.left != null)
    if (curr.right != null)
}
Binary Tree Vertical Order Traversal


TreeNode (left/right/val/count)
insertNode(int val, TreeNode root) {
    while (true) {
        if (root.val >= val)
        else
    }
}
Count of Smaller Numbers After Self


Stack<Character>
visited[26]
count[26]
for (int i = 0; i < s.length(); i++) {
    ...
    while(!stack.isEmpty() && stack.peek() > c && count[c-'a'] > 0) {
        visited[stack.peek()-'a'] = false;
        stack.pop();
    }
    stack.push(c);
    visited[c] = true;
}
Remove Duplicate Letters


int[] arr = new int[words.length];
for every arr[i] calculate arr[i] |= 1 << (tmp.charAt(j)-'a')
Maximum Product of Word Lengths


helper(word, res, index+1, curr, count+1);
helper(word, res, index+1, curr + (count == 0 ? "" : count) + word.charAt(index), 0);
Generalized Abbreviation (helper(word, res, 0, "", 0))


Number of Connected Components in an Undirected Graph (Graph Valid Tree)


if (sum == k)
if (map.containKey(sum-k))
if (!map.containsKey(sum))
Maximum Size Subarray Sum Equals k

dfs(int i, int j, int[][] matrix, int[][] cache) {
    if (cache[i][j] > 0) return cache[i][j];
    int curr = 0;
    for (k = 0; k < 4...) {
        if (increase)
            curr = Math.max(curr, dfs())
    }
    cache[i][j] = curr + 1;
    return cache[i][j];
}
Longest Increasing Path in a Matrix


dfs("JFK", res, map)
Reconstruct Itinerary


Increasing Triplet Subsequence (Max Diff in Array / Best Time buy stock i)


bottom up
House Robber III (Count Univalue Subtrees, Binary Tree Max Sum, Balanced Tree)


Counting Bits (Grey Code)


Stack<NestedInteger> stack
Flatten Nested List Iterator (Flat 2D Vector/Zigzag Iterator/Peeking Iterator/Binary Search Tree Iterator)


always has a 3
Integer Break


Top K Frequent Elements (Kth Largest Element in Array)



Data Stream as Disjoint Intervals


Count Numbers with Unique Digits (Paint Fence)


Logger Rate Limiter (Map<String, Integer>)
Design Hit Counter (Deque<Integer>))


Sorted Transformed Array (a>0 parabola open upward a<0 parabola open downward)


int rowCount; int[] colCount;
for (i) {
    for (j) {
        if (j == 0 || grid[i][j-1] == 'W')
        if (i == 0 || grid[i-1][j] == 'W')
        if (grid[i][j] == '0') res = Math.max
    }
}
Bomb Enemy


currSum += nums[i];
Integer curr = set.ceiling(currSum - k);
if (curr != null) res = Math.max(res, currSum - curr);
set.add(currSum);
Max Sum of Rectangle No Larger Than k (Maximum Size Subarray Sum Equals k / Minimum Size )


if (ni.isInteger()) res[0] += (int)ni.getInteger() * level;
else dfs(ni.getList(), level+1, res);
Nested List Weight Sum
int intSum = prev, listSum = 0;
for 
    if (ni.isInteger()) intSum += ni.getInteger();
    else list.addAll(ni.getList());
if (list.size() > 0) listSum = helper(list, intSum);
return intSum + listSum;
Nested List Weight Sum II


bottom up
Find Leaves of Binary Tree (Binary Tree Level Order Traversal)


if (p == null) return 1;
int carry = helper(p.next);
if (carry == 0) return 0;
int tmp = p.val + carry; p.val = tmp % 10; return tmp/10;
Plus One Linked List 


mark start with val and end + 1 with -val then sum all together
Range Addition


Combination Sum IV(Longest Increasing Subsequence / Coin Changes / Perfect Square review I II III)


create PriorityQueue<int[]>
assign first row to heap
while (k-- > 0) {
    res = heap.poll();
    if (res[2]+1<matrix[0].length) heap.offer
}
Kth Smallest Element in a Sorted Matrix
Find K Pairs with Smallest Sums


LinkedList<Integer> list;
Set<Integer> set;
Design Phone Directory








