Array

Two Sum (注意:题目假设只有一个解)
两种方法 第一种用HashMap 
HashMap<Integer, Integer> map 保存数字和其对应索引
for i=0; i<numbers.length; i++
    if(map.containsKey(target-numbers[i]))
        保存结果 返回
    map中存入记录
return res

时间O(n) 空间O(n)


第二种先排序然后两边夹逼 这种比较好应付不只有一个解的情况 不过这题要求输出数字的index而不是数字本身 所以要多开一个HashMap纪录数字原始的index
时间O(nlogn＋n)=O(nlogn) 空间O(n)





Two Sum ii - input array is sorted
这题假设数组已排好序 可以直接用两边夹逼的方法做出 
while(left<right)
    if(numbers[left]+numbers[right]==target)
        保持结果 返回
    else if >target
        right--;
    else
        left++;
return res;

时间O(n) 空间O(1)





Two Sum iii - Data Structure Design
1 add O(n)  find O(1)   Space: O(n^2)
Store all possible sum pairs in a hashtable. We also need a list of all added numbers. Each add go through the list and form
new sum pairs that put into the hashtable. For find, it is just a look up in the hashtable. This is useful if the find operation
is far exceed the add operation

2 add O(n)  find O(n)   Space: O(n)
Maintain a sorted array. For add, use method in Search Insert Position to find the place to insert in O(logn). Also we need to
move all the elements after the insert element in the array so that would be O(n). For find, use two pointer method in Two Sum
and it will cost O(n)

3 add O(1)  find O(nlogn)   Space: O(n)
No need to Maintain the sorted array. For add, just insert the element in the array. For find, we first sort the array in O(nlogn)
then use two sum method to find the element in O(n)

4 add O(1)  find O(n)   Space O(n)
Use a hashtable to save the number. Key is the added number and value is the count number of this number. For add, we update the
hashtable. For find, we look up the hashtable. Be careful for the duplicate number

public class TowSum {

    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

    public void add(int number) {
        if(map.containsKey(number))
            map.put(number, map.get(number)+1);
        else
            map.put(number, 1);
    }

    public int find(int number) {
        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int num1 = entry.getKey();
            int num2 = number - num1;
            if(num1==num2) {        //如果重复元素 要判断是否出现2次以上
                if(map.get(num2)>=2)
                    return true;
            } else if(map.containsKey(num2))    //否则如果包含num2 返回true
                return true;
        }
        return false;
    }
}





3Sum (数组中可能有重复值)
Arrays.sort(num);
for(int i=num.length-1; i>=2; i--)
    判断重复 continue
    List<List<Integer>>　item = twoSum(num, i-1; -num[i]);
    for(int i=0; i<item.size(); i++)
        item.add(num[i]);
    res.addAll(item);

List<list<Integer>>　twoSum(int[] num, int end, int target) {
    while(left<right)
        if ==target
            加入结果
            left++; right--;
            while left<right && num[left]==num[left-1]
                left++;
            while left<right && num[right]==num[right+1]
                right--;
        else if >target
            right--;
        else left++
}
时间O(n^2)    空间O(n)





3Sum Closest (find three integers that sum is closest to a given number. Return the sum. Only one solution)
3Sum变体
初始化global_minDiff = num[0]+num[1]+num[2]-target
Arrays.sort(num);
for i=0; i<num.length-2; i++
    int diff = twoSum(num, i+1, -num[i]);
    if global_minDiff大 更新
return target+global_minDiff;

int twoSum(int[] num, int start, int target)
初始化minDiff
while(left<right)
    if ==target
        return;
    int localDiff = num[left]+num[right]-target;
    if minDiff大 更新
    if >target
        right--;
    else left++;





4Sum
仍是先对数组排序 从后往前扫一遍数组 对于非重复元素 调用3Sum subroutine后面跟3Sum一样 时间O(n^3)

此题还有一种解法可以达到O(n^2logn) 有时间看





Best Time to Buy and Sell Stock (一次交易的最大利润)
动态规划 局部解全局解
for i=1; i<prices.length; i++
    local = Math.max(local[i]+prices[i]-prices[i-1], 0);
    global = Math.max(global, local);

时间O(n) 空间O(1)





Best Time to Buy and Sell Stock ii (无限次交易的最大利润)
这题更简单 不限定交易次数那么只要差价大于0就可以一直累加 
for i=1; i<prices.length; i++
    if(prices[i]-prices[i-1]>0)
        maxProfit+=prices[i]-prices[i-1];
时间O(n) 空间O(1)





Best Time to Buy and Sell Stock iii (限定2次交易 扩展到k次)
local[i][j]=max(local[i-1][j]+diff, global[i-1][j-1]+max(diff,0)) 
global[i][j]=max(local[i][j],global[i-1][j])
for i=1; i<prices.length; i++
    int diff = prices[i]-prices[i-1];
    for(j=2; j>=1; j--)
        local[j] = Math.max(local[j]+diff, global[j-1]+Math.max(diff,0));
        global[j] = Math.max(local[j], global[j]);





Best Time to Buy and Sell Stock iv
ii iii结合





Combination Sum (找和为指定target的集合 每个元素可以用无限次)
NP问题
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0
for i=start; i<candidates.length; i++
    if(i>0 && candidates[i]==candidates[i-1])
        continue;
    item.add();
    helper(candidates, i, item, target-candidates[i], res);
    item.remove();





Combination Sum ii (每个元素只能用一次)
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0 || start==candidates.length;
for i=start; i<candidates.length; i++
    if i>start && candidates[i]==candidates[i-1]
        continue;
    item.add();
    helper(candidates, i+1, item, target-candidates[i], res);
    item.remove();

    



Construct Binary Tree from Preorder and Inorder Traversal
树题 递归
HashMap<Integer, Integer> map 保存中序值和索引的对应关系
helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1, map);

TreeNode helepr() {
    if inL>inR || preL>preR
        return null;
    TreeNode root = new TreeNode(preorder[preL]);
    int index = map.get(preorder[preL]);
    root.left = 
    root.right = 
    return root;
}





Construct Binary Tree from Inorder and Postorder Traversal
同上





Container With Most Water
求两条垂直x轴的线和x轴围成的container里能乘的最大水量
while left<right
    int diff
    if diff>0
        int localWater = (right-left)*height[left];
        maxWater = maxWater<localWater ? localWater:maxWater;
        left++;
    else
        同上 right

时间O(n) 空间O(1)





Trapping Rain Water
上一题的进阶版 不是和x轴围 而是和中间其他高度围

两种解法 第一种扫两遍 先左扫一遍 再右扫一遍
for(int i=1; i<A.length-1; i++) {
    leftMax = Math.max(leftMax, A[i-1]);
    maxL[i] = leftMax;
}
int rightMax = 0;
for(int i=A.length-2; i>0; i--) {
    rightMax = Math.max(rightMax, A[i+1]);
    water+=Math.min(maxL[i], rightMax)>A[i]?Math.min(maxL[i], rightMax)-A[i]:0;
}

时间O(2*n)=O(n) 空间O(n)

第二种解法只需要扫一次数组 比较左右指针 取小的那边开始走 如果下一个元素更小就把差值加到结果中 否则重新比较左右指针大小 
while(left<right) {
    int minHeight = Math.min(A[left], A[right]);
    if(A[left]==minHeight) {
        left++;
        while(left<right && A[left]<=minHeight) {
            water+=minHeight-A[left];
            left++;
        }
    }
    else {
        right 同上
    }

时间O(n) 空间O(1)





Find Minimum in Rotated Array i (i假定没有重复元素 二有)
while left<right &&　num[left]>num[right]
    int mid = (left_right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else
        right = mid;
return num[left];

时间O(logn) 空间O(1)





Find Minimum in Rotated Array ii
while left<right
    int mid = (left+right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else if(num[mid]<num[right])
        right = mid;
    else
        right--;
return num[left];

时间O(logn) 空间O(1)





Search in Rotated Sorted Array
while(left<=right)
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
时间O(logn) 空间O(1)





Search in Rotated Sorted Array ii
while left<=right
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else if(A[mid]<A[right]) {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
    else
        right--;
时间最坏是O(n) 空间O(1)





Find Peak Element
还是二分法思路 
while(left<right) {
    int mid = (left+right)/2;
    if(num[mid]<num[mid+1])
        left = mid + 1;
    else
        right = mid;
}
return left;
时间O(logn) 空间O(1)





First Missing Positive integer
for i=0; i<A.length; i++
    if(A[i]>0 && A[i]<A.length+1 && A[A[i]-1]=A[i])
        int tmp = A[A[i]-1];
        A[A[i]-1] = A[i];
        A[i] = tmp;
        i--;
for i=0; i<A.length; i++
    if A[i]!=i+1;
        return i+1;
return A.length+1;

时间O(n) 空间O(1)





Merge Intervals
先对interval排序 然后扫一遍interval 如果当前interval和结果集中最后一个有重叠 就把结果集中最后一个元素的end设为它和当起interval的end中较大值

否则直接将当前interval加到结果集中

排序要用到Comparator接口 具体如下
Comparator<Interval> comp = new Comparator<Interval>()  
{  
    @Override  
    public int compare(Interval i1, Interval i2)  
    {  
        if(i1.start==i2.start)  
            return i1.end-i2.end;  
        return i1.start-i2.start;  
    }  
};  
Collections.sort(intervals,comp);  

时间O(n) 空间O(1)





Insert Intervals
这题是上一题的进阶版 先扫一遍list找到newInterval.start<intervals.get(i).end 如果有这个interval就先将newInterval.start和intervals.get(i).start

merge 然后将newInterval插入位置i i++跳到下一个位置 从i开始往后扫 只要newInterval.end跟当前interval.get(i)有交集 就将它合并进newInterval

并从原list中remove这个interval 时间O(n) 空间O(1)





Jump Game
动态规划题
reach = 0
for i=0; i<A.length&&i<=reach; i++
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return false;
return true;

时间O(n) 空间O(1)





Jump Game ii
int step = 0, reach = 0, lastReach = 0;
for i=0; i<A.length&&i<=reach; i++
    if(i>lastReach)
        step++;
        lastReach = reach;
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return -1;
return step;

时间O(n) 空间O(1)





Largest Rectangle in Histogram
维护一个栈 栈里的元素是递增的 扫一遍数组如果当前元素小于栈顶元素那么就一直出栈直到栈顶元素小于当前元素 在这个过程中计算每个矩阵的面积 关键代码如下
peekIndex = stack.pop();
int width = stack.isEmpty()?i:i-stack.peek()-1;
maxArea = Math.max(maxArea, width*height[peekIndex]);

最后循环结束还要检查下栈是否为空 不为空要将元素都弹出计算面积 时间O(n) 空间最坏O(n)



Maximal Rectangle
这题是上一题的扩展 求0-1矩阵面积最大的全1矩阵 对于矩阵每一行可以用上一题的routine来求出最大面积 一共有m行所以要调m次 在计算的过程中只需要维护上一行

的高度就可以了 如果下一行对应元素为0则高度是0 否则时上一行高度加1 这样在线性时间里就可以完成对高度的更新 Largest Rectangle in Histogram的复杂度

为O(n) 而计算一行高度的复杂度也为O(n) 所以每一行的复杂度是O(n+n)=O(n) 总时间复杂度O(m*n) 空间上需要保存一行直方图的高度O(n)加上Largest Rectangle

in Histogram所使用的空间O(n) 总空间复杂度还是O(n)



Longest Consecutive Sequence
这题借用了图的思想 将每个元素看作图的一个顶点 相邻的数就是它的边 做一次深度优先遍历 找出当前元素的最大连续子串过程中移除用过的元素

实现上先将所有元素放入一个HashSet 只要set不空就一直循环 每次从set中取出一个元素 找它相邻左右的元素是否在set中 在就将长度＋1并将此元素从set中移除

最后更新最大长度 退出循环时返回最大长度即可



Majority Element
Moore voting algorithm 扫一遍数组 维护一个count和一个curr变量 如果相同变量count＋1 否则count－1 如果count为0 则更新curr为num[i] 因为存在

大于半数的元素 所以这样累加抵消的最终结果一定是那个大于半数的数 时间O(n) 空间O(1)



Maximum Subarray
经典动态规划问题 局部解全局解 递推式为 local[i+1] = Math.max(A[i+1], local[i]+A[i+1]), global[i+1] = Math.max(local[i+1], global[i])

时间O(n) 空间O(1)



Maximum Product Subarray
还是局部最优全局最优 只是要多维护一个当前最小值 因为乘法的特性 现在很小的值可以和后面负数产生最大值 其他跟Maximum Subarray那题差不多



Median of Two Sorted Arrays
求两个有序数组的中位数 时间要在log(m+n) k初始为A B数组长度的一半 每次两个数组各取第k/2号元素 比较大小 如果A小就把A[k/2]以前的元素都剔除掉 如果B小就把

B[k/2]以前的元素都剔除掉 相等就直接返回 这样每次都能删除k/2个元素 当k最终等于1时返回Math.min(A[startA], B[startB]) 或若最终A的长度为0就返回

B[startB+k-1] 时间O(log(m+n)) 空间O(log(m+n))



Merge Sorted Array
因为A has enough space所以从A的m+n-1个元素开始 比较A[m-1]和B[n-1]将大的值放入A[m+n-1] 如此循环直到一个数组为空 之后如果B中还有元素依次放入A

A中元素已经就位不用管了 时间O(n) 空间O(1)



Unique Paths
动态规划 递推式为res[i][j] = res[i][j-1]+res[i-1][j] 维护一个列大小的一维数组 从第一行开始扫 每次更新res[j]+=res[j-1] 最后返回res[n-1]

时间O(m*n) 空间O(n)



Unique Paths ii
思路同上一题 只是这里有不能走的格子 递推式是若当前格子不为1则同上一题res[i][j]=res[i][j-1]+res[i-1][j] 否则res[i][j]=0 还是从第一行开始扫

每次判断一下当前格子是否为1 然后用对应递推式更新即可 时间O(m*n) 空间O(n)



Minimum Path Sum
跟Unique Paths系列差不多 只是这次每个格子有值相当于有权重 仍然是用一维数组 首先给数组赋初值将第一行每个元素的累加值放到对应数组元素中 然后从第二行开始

更新res的值 如果是第一列元素res[j]+=grid[i][j] 否则res[j] = Math.min(res[j], res[j-1]) + grid[i][j] 时间O(m*n) 空间O(n)



Next Permutation
从后往前扫一遍数组 找到第一个违反递增顺序的元素 如果不存在返回最大的序列 否则再从这个元素往后扫找到比它大的数中最小的那个交换他们的位置 在就将

他们交换位置 并把后面的元素reverse即可 最坏要扫三次 时间O(3*n)=O(n) 空间O(1)



Pascal Triangle
根据行数创建杨辉三角 思路很简单 先创建第一行 然后从第二行开始循环  时间O(n^2) 空间O(1)



Pascal Triangle ii
求k行的杨辉三角 比上一题还容易 时间O(n^2) 空间O(1)



Plus One
循环加1操作 每次更新digits[i]和carry 如果carry不为0就一直循环 为0则返回结果 最后如果还有进位则要新建一个长度为digits.length+1数组 

将头元素设为1 时间O(n) 空间一般是O(1) 最坏为O(n)



Remove Duplicates from Sorted Array
设index为1 从数组第二个元素开始扫 每次比较index-1和i指向的元素是否相等 若相等A[index]=A[i] index++ 否则进入下一次循环 最后返回index即可

时间O(n) 空间O(1)



Remove Duplicates from Sorted Array ii
跟上题思路类似 只是可以重复一次 设index为2 从数组第三个元素开始扫 比较index-2和i指向的元素是否相等 若相等A[index]=A[i] index++ 

否则进入下一次循环 时间O(n) 空间O(1)



Remove Element
两种解法 思路差不多 从前往后扫 时间O(n) 空间O(1)
for(int i=0; i<=len; i++) {
    if(A[i]==elem)
        A[i--] = A[len--]; 
}

从后往前
for(int i=A.length-1; i>-1; i--)
{
    if(A[i]==elem)  
    {
        A[i] = A[j--];   
    }
}



Rotate Array
<<<<<<< HEAD
思路比较简单 先反转整个数组 然后
=======
先对这个数组反转 然后反转0到k－1 再反转k到num.length-1即可



Rotate Image
矩阵相关操作 考察数组的操作 一层一层旋转 每次都是保存上 然后上变左 左变下 下变右 右变上 循环为
for(int layer=0; layer<matrix.length/2; layer++)
    for(int i=layer; i<matrix.length-1-layer; i++)



Search Insert Position
二分法变体 仍然是二分法套路 每次取mid值等于直接返回 大于right=mid-1 小于left=mid+1 如果最后出循环仍没有找到就返回left 时间O(logn) 空间O(1)



Search a 2D Matrix
二分法变体 用两次二分法 第一次确定行数 如果target超出行数范围则matrix没有target 否则确定行数后找列数 最后返回结果 时间O(logn) 空间O(1)



Search for a Range
二分法变体 三次二分法 第一次找值是否存在 第二次找左边界的值 查找条件为
if(A[m]==target)  
    newR = m - 1;
else
    newL = m + 1;
第三遍找右边界的值 查找条件同上 时间O(logn) 空间O(1)







Set Matrix Zeroes
先判断矩阵第一行和第一列是否有0 标记好 然后一行行扫矩阵 如果碰到0就把这个元素对应的行数和列数存在第一行和第一列里 之后再扫一遍矩阵如果某个元素对应第一行

或第一列为0则将这个元素设为0 最后根据标记将第一行和第一列设为0即可 时间O(m*n) 空间O(1)



Sort Colors
这题主要复习计数排序的思路 最好的思路是利用元素只有3种值的特点 扫一遍数组维护2个指针 一个将指向的数字变为1一个变味0 i将碰到的所有元素变为2 这样扫完一遍就

得到了结果 时间O(n) 空间O(1)



Spiral Matrix
执行一个while循环 维护4个变量left, right, up, down代表4个方向和一个当前方向的变量direction 每次读取direction方向的变量并加到结果集 当left>right

或者up<down时退出循环返回结果 时间O(m*n) 空间O(1)



Spiral Matrix ii
同上一题 还是每次读一行或一列的值 加到结果数组中 时间O(n*n) 空间O(1)



Subsets
先排序 然后递归从空集开始每次把数组新的元素加到已有的所有集合中 时间O(2^n) 空集O(2^n)



Subsets ii
同上一题 会有重复元素 需要用一个变量lastSize标记上一次结果集的最后一个集合 如果下一个元素是重复的就把这个元素加到最后一个集合里构成新的子集 而其他的子集

上一次已经加过了所以不用再加了 时间空间仍是指数级的






Triangle
动态规划题 建立一个数组sum[triangle.size()] sum[0]=triangle.get(0).get(0) 从第二行开始每次从后往前扫 单独处理第一个和最后一个元素 对于一般的元素

取上一行相邻两个元素中最小的那个加上当前行对应元素值 代码如下
sum[i] = sum[i-1] + triangle.get(i).get(i);     
for(int j=i-1; j>=1; j--) {                    
    sum[j] = sum[j]<sum[j-1]?sum[j]:sum[j-1] + triangle.get(i).get(j);
}
sum[0] += triangle.get(i).get(0);



Word Search
图的思想 深度优先遍历 从某一点出发 如果当前元素是word中对应的字母 将当前字符标记为已访问继续递归上下左右四条边 如果最终长度等于word返回true 否则

如果坐标超出范围 或该字符已被访问过 或它不等于对应word中的字符返回false 如果从一个新的字符出发要重置访问标记 时间复杂度 空间O(m*n)































>>>>>>> f577b1f2d86f7991c70d64a63aead74e3fa827a4
















