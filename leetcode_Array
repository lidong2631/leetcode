Array

Two Sum (注意:题目假设只有一个解)
两种方法 第一种用HashMap 
HashMap<Integer, Integer> map 保存数字和其对应索引
for i=0; i<numbers.length; i++
    if(map.containsKey(target-numbers[i]))
        保存结果 返回
    map中存入记录
return res

时间O(n) 空间O(n)


第二种先排序然后两边夹逼 这种比较好应付不只有一个解的情况 不过这题要求输出数字的index而不是数字本身 所以要多开一个HashMap纪录数字原始的index
时间O(nlogn＋n)=O(nlogn) 空间O(n)





Two Sum ii - input array is sorted
这题假设数组已排好序 可以直接用两边夹逼的方法做出 
while(left<right)
    if(numbers[left]+numbers[right]==target)
        保持结果 返回
    else if >target
        right--;
    else
        left++;
return res;

时间O(n) 空间O(1)





Two Sum iii - Data Structure Design
1 add O(n)  find O(1)   Space: O(n^2)
Store all possible sum pairs in a hashtable. We also need a list of all added numbers. Each add go through the list and form
new sum pairs that put into the hashtable. For find, it is just a look up in the hashtable. This is useful if the find operation
is far exceed the add operation

2 add O(n)  find O(n)   Space: O(n)
Maintain a sorted array. For add, use method in Search Insert Position to find the place to insert in O(logn). Also we need to
move all the elements after the insert element in the array so that would be O(n). For find, use two pointer method in Two Sum
and it will cost O(n)

3 add O(1)  find O(nlogn)   Space: O(n)
No need to Maintain the sorted array. For add, just insert the element in the array. For find, we first sort the array in O(nlogn)
then use two sum method to find the element in O(n)

4 add O(1)  find O(n)   Space O(n)
Use a hashtable to save the number. Key is the added number and value is the count number of this number. For add, we update the
hashtable. For find, we look up the hashtable. Be careful for the duplicate number

public class TowSum {

    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

    public void add(int number) {
        if(map.containsKey(number))
            map.put(number, map.get(number)+1);
        else
            map.put(number, 1);
    }

    public int find(int number) {
        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int num1 = entry.getKey();
            int num2 = number - num1;
            if(num1==num2) {        //如果重复元素 要判断是否出现2次以上
                if(map.get(num2)>=2)
                    return true;
            } else if(map.containsKey(num2))    //否则如果包含num2 返回true
                return true;
        }
        return false;
    }
}





3Sum (数组中可能有重复值)
Arrays.sort(num);
for(int i=num.length-1; i>=2; i--)
    判断重复 continue
    List<List<Integer>>　item = twoSum(num, i-1; -num[i]);
    for(int i=0; i<item.size(); i++)
        item.add(num[i]);
    res.addAll(item);

List<list<Integer>>　twoSum(int[] num, int end, int target) {
    while(left<right)
        if ==target
            加入结果
            left++; right--;
            while left<right && num[left]==num[left-1]
                left++;
            while left<right && num[right]==num[right+1]
                right--;
        else if >target
            right--;
        else left++
}
时间O(n^2)    空间O(n)





3Sum Closest (find three integers that sum is closest to a given number. Return the sum. Only one solution)
3Sum变体
初始化global_minDiff = num[0]+num[1]+num[2]-target
Arrays.sort(num);
for i=0; i<num.length-2; i++
    int diff = twoSum(num, i+1, -num[i]);
    if global_minDiff大 更新
return target+global_minDiff;

int twoSum(int[] num, int start, int target)
初始化minDiff
while(left<right)
    if ==target
        return;
    int localDiff = num[left]+num[right]-target;
    if minDiff大 更新
    if >target
        right--;
    else left++;





4Sum
仍是先对数组排序 从后往前扫一遍数组 对于非重复元素 调用3Sum subroutine后面跟3Sum一样 时间O(n^3)

此题还有一种解法可以达到O(n^2logn) 有时间看





Best Time to Buy and Sell Stock (一次交易的最大利润)
动态规划 局部解全局解
for i=1; i<prices.length; i++
    local = Math.max(local[i]+prices[i]-prices[i-1], 0);
    global = Math.max(global, local);

时间O(n) 空间O(1)





Best Time to Buy and Sell Stock ii (无限次交易的最大利润)
这题更简单 不限定交易次数那么只要差价大于0就可以一直累加 
for i=1; i<prices.length; i++
    if(prices[i]-prices[i-1]>0)
        maxProfit+=prices[i]-prices[i-1];
时间O(n) 空间O(1)





Best Time to Buy and Sell Stock iii (限定2次交易 扩展到k次)
local[i][j]=max(local[i-1][j]+diff, global[i-1][j-1]+max(diff,0)) 
global[i][j]=max(local[i][j],global[i-1][j])
for i=1; i<prices.length; i++
    int diff = prices[i]-prices[i-1];
    for(j=2; j>=1; j--)
        local[j] = Math.max(local[j]+diff, global[j-1]+Math.max(diff,0));
        global[j] = Math.max(local[j], global[j]);





Best Time to Buy and Sell Stock iv
ii iii结合





Combination Sum (找和为指定target的集合 每个元素可以用无限次)
NP问题
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0
for i=start; i<candidates.length; i++
    if(i>0 && candidates[i]==candidates[i-1])
        continue;
    item.add();
    helper(candidates, i, item, target-candidates[i], res);
    item.remove();





Combination Sum ii (每个元素只能用一次)
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0 || start==candidates.length;
for i=start; i<candidates.length; i++
    if i>start && candidates[i]==candidates[i-1]
        continue;
    item.add();
    helper(candidates, i+1, item, target-candidates[i], res);
    item.remove();

    



Construct Binary Tree from Preorder and Inorder Traversal
树题 递归
HashMap<Integer, Integer> map 保存中序值和索引的对应关系
helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1, map);

TreeNode helepr() {
    if inL>inR || preL>preR
        return null;
    TreeNode root = new TreeNode(preorder[preL]);
    int index = map.get(preorder[preL]);
    root.left = 
    root.right = 
    return root;
}





Construct Binary Tree from Inorder and Postorder Traversal
同上





Container With Most Water
求两条垂直x轴的线和x轴围成的container里能乘的最大水量
while left<right
    int diff
    if diff>0
        int localWater = (right-left)*height[left];
        maxWater = maxWater<localWater ? localWater:maxWater;
        left++;
    else
        同上 right

时间O(n) 空间O(1)





Trapping Rain Water
上一题的进阶版 不是和x轴围 而是和中间其他高度围

两种解法 第一种扫两遍 先左扫一遍 再右扫一遍
for(int i=1; i<A.length-1; i++) {
    leftMax = Math.max(leftMax, A[i-1]);
    maxL[i] = leftMax;
}
int rightMax = 0;
for(int i=A.length-2; i>0; i--) {
    rightMax = Math.max(rightMax, A[i+1]);
    water+=Math.min(maxL[i], rightMax)>A[i]?Math.min(maxL[i], rightMax)-A[i]:0;
}

时间O(2*n)=O(n) 空间O(n)

第二种解法只需要扫一次数组 比较左右指针 取小的那边开始走 如果下一个元素更小就把差值加到结果中 否则重新比较左右指针大小 
while(left<right) {
    int minHeight = Math.min(A[left], A[right]);
    if(A[left]==minHeight) {
        left++;
        while(left<right && A[left]<=minHeight) {
            water+=minHeight-A[left];
            left++;
        }
    }
    else {
        right 同上
    }

时间O(n) 空间O(1)





Find Minimum in Rotated Array i (i假定没有重复元素 二有)
while left<right &&　num[left]>num[right]
    int mid = (left_right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else
        right = mid;
return num[left];

时间O(logn) 空间O(1)





Find Minimum in Rotated Array ii
while left<right
    int mid = (left+right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else if(num[mid]<num[right])
        right = mid;
    else
        right--;
return num[left];

时间O(logn) 空间O(1)





Search in Rotated Sorted Array
while(left<=right)
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
时间O(logn) 空间O(1)





Search in Rotated Sorted Array ii
while left<=right
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else if(A[mid]<A[right]) {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
    else
        right--;
时间最坏是O(n) 空间O(1)





Find Peak Element
还是二分法思路 
while(left<right) {
    int mid = (left+right)/2;
    if(num[mid]<num[mid+1])
        left = mid + 1;
    else
        right = mid;
}
return left;
时间O(logn) 空间O(1)





First Missing Positive integer
for i=0; i<A.length; i++
    if(A[i]>0 && A[i]<A.length+1 && A[A[i]-1]=A[i])
        int tmp = A[A[i]-1];
        A[A[i]-1] = A[i];
        A[i] = tmp;
        i--;
for i=0; i<A.length; i++
    if A[i]!=i+1;
        return i+1;
return A.length+1;

时间O(n) 空间O(1)





Merge Intervals
Comparator<Interval> cmp = new Comparator<Interval>(){
    public int compare(Interval i1, Interval i2) {
        if(i1.start==i2.start)
            return i1.end-i2.end;
        return i1.start-i2.start;
    }
};
Collections.sort(intervals, cmp);
for(int i=1; i<intervals.size(); i++)
    if(intervals.get(i).start<=intervals.get(i-1).end)
        intervals.get(i-1).end = Math.max(intervals.get(i-1).end, intervals.get(i).end);
        intervals.remove(i);
        i--;

时间O(n) 空间O(1)





Insert Intervals
这题是上一题的进阶版 
while(i<intervals.size() && intervals.get(i).end<newInterval.start)
    i++;
if(i<intervals.size());
    newInterval.start = Math.min(newInterval, intervals.get(i).start);
intervals.add(i, newInterval);
i++;
while(i<intervals.size() &&　newInterval.end>=intervals.get(i).start)
    newInterval.end = Math.max(newInterval.end, intervals.get(i).end);
    intervals.remove(i);

时间O(n) 空间O(1)





Jump Game
动态规划题
reach = 0
for i=0; i<A.length&&i<=reach; i++
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return false;
return true;

时间O(n) 空间O(1)





Jump Game ii
int step = 0, reach = 0, lastReach = 0;
for i=0; i<A.length&&i<=reach; i++
    if(i>lastReach)
        step++;
        lastReach = reach;
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return -1;
return step;

时间O(n) 空间O(1)





Largest Rectangle in Histogram
第一种做法对于每一个高度 分别往左右走找到它的最大面积 最后取所有最大面积中最大的 时间O(n^2) 空间O(1)

第二种做法 利用栈维护一个递增序列
for i=0; i<height.length; i++;
    if(stack.isEmpty() || height[i]>height[stack.peek()])
        stack.push(i);
    else {
        int currIndex = stack.pop();
        int width = stack.isEmpty()? i:i-stack.peek()-1;
        maxArea = Math.max(maxArea, width*height[i]);
        i--;
    }
while(!stack.isEmpty()) {
    int currIndex = stack.pop();
    int width = stack.isEmpty()? i:i-stack.peek()-1;
    maxArea = Math.max(maxArea, width*height[i]);
}

时间O(n) 空间O(n)





Maximal Rectangle
这题是上一题的扩展 
for int i=0; i<matrix.length; i++
    for int j=0; j<matrix[0].length; j++
        height[j] = matrix[i][j]=='0'? 0:height[j]+1;
    maxArea = Math.max(maxArea, largestRect(height));

时间上Largest Rectangle in Histogram的复杂度为O(n) 而计算一行高度的复杂度也为O(n) 所以每一行的复杂度是O(n+n)=O(n) 

总时间复杂度O(m*n) 空间上需要保存一行直方图的高度O(n)加上Largest Rectangle in Histogram所使用的空间O(n) 总空间复杂度还是O(n)





Longest Consecutive Sequence
1 先排序在统计最长连续子序列 时间O(nlogn)

2
HashSet<Integer> set 记录所有数

while(!set.isEmpty()) {
    Iterator i = set.iterator();
    int n = (int)i.next();
    set.remove(n);
    int left = n-1; l = 0;
    while(set.contains(left)) {
        l++;
        set.remove(left);
        left--;
    }
    right同left
    maxLen = Math.max(maxLen, l+1+r);
}

时间O(n) 空间O(n)





Majority Element
Moore voting algorithm
for i=0; i<num.length; i++
    if(count==0)
        major = num[i];
        count++;
    else if(major==num[i])
        count++;
    else count--;

时间O(n) 空间O(1)





Maximum Subarray
动态规划问题 递推式为 local[i+1] = Math.max(A[i+1], local[i]+A[i+1]), global[i+1] = Math.max(local[i+1], global[i])
int local = A[0], global = A[0];
for(int i=1; i<A.length; i++) {
    local = Math.max(local+A[i], A[i]);
    global = Math.max(global, local);
}

时间O(n) 空间O(1)





Maximum Product Subarray
int maxLocal = A[0], minLocal = A[0], maxCopy = A[0];
for(int i=1; i<A.length; i++) {
    int maxCopy = maxLocal;
    maxLocal = Math.max(maxLocal*A[i], Math.max(A[i], minLocal*A[i]));
    minLocal = Math.min(minLocal*A[i], Math.min(A[i], maxCopy*A[i]));
    global = Math.max(global, maxLocal);
}

时间O(n) 空间O(1)





Median of Two Sorted Arrays
if((A.length+B.length)%2==1)
else

private int helper(A, startA, endA, B, startB, endB, k) {
    lenA = endA-startA+1;
    lenB = endB-startB+1;
    if(lenA>lenB)
        return helper(B, startB, endB, A, startA, endA, k);
    if(k==1)
        return Math.min(A[startA], B[startB]);
    if(lenA==0)
        return B[startB+k-1];
    int posA = Math.min(k/2, lenA);
    int posB = k-posA;
    if(A[startA+posA-1]==B[startB+posB-1])
        return A[startA+posA-1];
    else if(A[startA+posA-1]>B[startB+posB-1])
        return helper(A, startA, startA+postA-1, B, startB+posB, endB, k-posB);
    else
        return helper(A, startA+posA, endA, B, startB, startB+posB+1, k-posA);
}

时间O(log(m+n)) 空间O(logk)





Merge Sorted Array
int indexA = m-1, indexB = n-1, index = m+n-1;
while(indexA>=0 && indexB>=0) {
    if(A[indexA]>B[indexB])
        A[index--] = A[indexA--];
    else
        A[index--] = B[indexB--];
}
while(indexB>=0)
    A[index--] = B[indexB--];

时间O(n) 空间O(1)





Unique Paths
动态规划 递推式为res[i][j] = res[i][j-1]+res[i-1][j]
res[0] = 1
for int i=0; i<m; i++
    for int j=1; j<n; j++
        res+=res[j-1]

时间O(m*n) 空间O(n)





Unique Paths ii
思路同上一题 只是这里有不能走的格子 递推式是若当前格子不为1则同上一题res[i][j]=res[i][j-1]+res[i-1][j] 否则res[i][j]=0 
res[0] = 1;
for i=0; i<obstacleGrid.length; i++
    for j=0; j<obstacleGrid[0].length; j++
        if(obstacleGrid[i][j]==1)
            res[j] = 0;
        else
            if(j>0)
                res[j]+=res[j-1];

时间O(m*n) 空间O(n)





Minimum Path Sum
带权重的最小路径和 如果是第一列元素res[j]=res[j-1]+grid[i][j] 否则res[j] = Math.min(res[j], res[j-1]) + grid[i][j] 
res[0] = grid[0][0];
for(int i=1; i<grid[0].length; i++)
    res[j] = res[j-1] + grid[0][i];
for i=1; i<grid.length; i++
    for j=0; j<grid[0].length; j++
        if(j==0)
            res[j]+=grid[i][0];
        else
            res[j] = grid[i][j]+Math.min(res[j], res[j-1]);

时间O(m*n) 空间O(n)





Next Permutation
从后往前扫一遍数组 找到第一个违反递增顺序的元素 如果不存在返回最大的序列 否则再从这个元素往后扫找到比它大的数中最小的那个交换他们的位置 在就将

他们交换位置 并把后面的元素reverse即可 最坏要扫三次 时间O(3*n)=O(n) 空间O(1)



Pascal Triangle
根据行数创建杨辉三角 思路很简单 先创建第一行 然后从第二行开始循环  时间O(n^2) 空间O(1)



Pascal Triangle ii
求k行的杨辉三角 比上一题还容易 时间O(n^2) 空间O(1)



Plus One
循环加1操作 每次更新digits[i]和carry 如果carry不为0就一直循环 为0则返回结果 最后如果还有进位则要新建一个长度为digits.length+1数组 

将头元素设为1 时间O(n) 空间一般是O(1) 最坏为O(n)



Remove Duplicates from Sorted Array
设index为1 从数组第二个元素开始扫 每次比较index-1和i指向的元素是否相等 若相等A[index]=A[i] index++ 否则进入下一次循环 最后返回index即可

时间O(n) 空间O(1)



Remove Duplicates from Sorted Array ii
跟上题思路类似 只是可以重复一次 设index为2 从数组第三个元素开始扫 比较index-2和i指向的元素是否相等 若相等A[index]=A[i] index++ 

否则进入下一次循环 时间O(n) 空间O(1)



Remove Element
两种解法 思路差不多 从前往后扫 时间O(n) 空间O(1)
for(int i=0; i<=len; i++) {
    if(A[i]==elem)
        A[i--] = A[len--]; 
}

从后往前
for(int i=A.length-1; i>-1; i--)
{
    if(A[i]==elem)  
    {
        A[i] = A[j--];   
    }
}



Rotate Array
<<<<<<< HEAD
思路比较简单 先反转整个数组 然后
=======
先对这个数组反转 然后反转0到k－1 再反转k到num.length-1即可



Rotate Image
矩阵相关操作 考察数组的操作 一层一层旋转 每次都是保存上 然后上变左 左变下 下变右 右变上 循环为
for(int layer=0; layer<matrix.length/2; layer++)
    for(int i=layer; i<matrix.length-1-layer; i++)



Search Insert Position
二分法变体 仍然是二分法套路 每次取mid值等于直接返回 大于right=mid-1 小于left=mid+1 如果最后出循环仍没有找到就返回left 时间O(logn) 空间O(1)



Search a 2D Matrix
二分法变体 用两次二分法 第一次确定行数 如果target超出行数范围则matrix没有target 否则确定行数后找列数 最后返回结果 时间O(logn) 空间O(1)



Search for a Range
二分法变体 三次二分法 第一次找值是否存在 第二次找左边界的值 查找条件为
if(A[m]==target)  
    newR = m - 1;
else
    newL = m + 1;
第三遍找右边界的值 查找条件同上 时间O(logn) 空间O(1)







Set Matrix Zeroes
先判断矩阵第一行和第一列是否有0 标记好 然后一行行扫矩阵 如果碰到0就把这个元素对应的行数和列数存在第一行和第一列里 之后再扫一遍矩阵如果某个元素对应第一行

或第一列为0则将这个元素设为0 最后根据标记将第一行和第一列设为0即可 时间O(m*n) 空间O(1)



Sort Colors
这题主要复习计数排序的思路 最好的思路是利用元素只有3种值的特点 扫一遍数组维护2个指针 一个将指向的数字变为1一个变味0 i将碰到的所有元素变为2 这样扫完一遍就

得到了结果 时间O(n) 空间O(1)



Spiral Matrix
执行一个while循环 维护4个变量left, right, up, down代表4个方向和一个当前方向的变量direction 每次读取direction方向的变量并加到结果集 当left>right

或者up<down时退出循环返回结果 时间O(m*n) 空间O(1)



Spiral Matrix ii
同上一题 还是每次读一行或一列的值 加到结果数组中 时间O(n*n) 空间O(1)



Subsets
先排序 然后递归从空集开始每次把数组新的元素加到已有的所有集合中 时间O(2^n) 空集O(2^n)



Subsets ii
同上一题 会有重复元素 需要用一个变量lastSize标记上一次结果集的最后一个集合 如果下一个元素是重复的就把这个元素加到最后一个集合里构成新的子集 而其他的子集

上一次已经加过了所以不用再加了 时间空间仍是指数级的






Triangle
动态规划题 建立一个数组sum[triangle.size()] sum[0]=triangle.get(0).get(0) 从第二行开始每次从后往前扫 单独处理第一个和最后一个元素 对于一般的元素

取上一行相邻两个元素中最小的那个加上当前行对应元素值 代码如下
sum[i] = sum[i-1] + triangle.get(i).get(i);     
for(int j=i-1; j>=1; j--) {                    
    sum[j] = sum[j]<sum[j-1]?sum[j]:sum[j-1] + triangle.get(i).get(j);
}
sum[0] += triangle.get(i).get(0);



Word Search
图的思想 深度优先遍历 从某一点出发 如果当前元素是word中对应的字母 将当前字符标记为已访问继续递归上下左右四条边 如果最终长度等于word返回true 否则

如果坐标超出范围 或该字符已被访问过 或它不等于对应word中的字符返回false 如果从一个新的字符出发要重置访问标记 时间复杂度 空间O(m*n)































>>>>>>> f577b1f2d86f7991c70d64a63aead74e3fa827a4
















