Array

Two Sum (注意:题目假设只有一个解)
两种方法 第一种用HashMap 
HashMap<Integer, Integer> map 保存数字和其对应索引
for i=0; i<numbers.length; i++
    if(map.containsKey(target-numbers[i]))
        保存结果 返回
    map中存入记录
return res

时间O(n) 空间O(n)


第二种先排序然后两边夹逼 这种比较好应付不只有一个解的情况 不过这题要求输出数字的index而不是数字本身 所以要多开一个HashMap纪录数字原始的index
时间O(nlogn＋n)=O(nlogn) 空间O(n)





Two Sum ii - input array is sorted
这题假设数组已排好序 可以直接用两边夹逼的方法做出 
while(left<right)
    if(numbers[left]+numbers[right]==target)
        保持结果 返回
    else if >target
        right--;
    else
        left++;
return res;

时间O(n) 空间O(1)





Two Sum iii - Data Structure Design
1 add O(n)  find O(1)   Space: O(n^2)
Store all possible sum pairs in a hashtable. We also need a list of all added numbers. Each add go through the list and form
new sum pairs that put into the hashtable. For find, it is just a look up in the hashtable. This is useful if the find operation
is far exceed the add operation

2 add O(n)  find O(n)   Space: O(n)
Maintain a sorted array. For add, use method in Search Insert Position to find the place to insert in O(logn). Also we need to
move all the elements after the insert element in the array so that would be O(n). For find, use two pointer method in Two Sum
and it will cost O(n)

3 add O(1)  find O(nlogn)   Space: O(n)
No need to Maintain the sorted array. For add, just insert the element in the array. For find, we first sort the array in O(nlogn)
then use two sum method to find the element in O(n)

4 add O(1)  find O(n)   Space O(n)
Use a hashtable to save the number. Key is the added number and value is the count number of this number. For add, we update the
hashtable. For find, we look up the hashtable. Be careful for the duplicate number

public class TowSum {

    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

    public void add(int number) {
        if(map.containsKey(number))
            map.put(number, map.get(number)+1);
        else
            map.put(number, 1);
    }

    public int find(int number) {
        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int num1 = entry.getKey();
            int num2 = number - num1;
            if(num1==num2) {        //如果重复元素 要判断是否出现2次以上
                if(map.get(num2)>=2)
                    return true;
            } else if(map.containsKey(num2))    //否则如果包含num2 返回true
                return true;
        }
        return false;
    }
}





3Sum (数组中可能有重复值)
Arrays.sort(num);
for(int i=num.length-1; i>=2; i--)
    判断重复 continue
    List<List<Integer>>　item = twoSum(num, i-1; -num[i]);
    for(int i=0; i<item.size(); i++)
        item.add(num[i]);
    res.addAll(item);

List<list<Integer>>　twoSum(int[] num, int end, int target) {
    while(left<right)
        if ==target
            加入结果
            left++; right--;
            while left<right && num[left]==num[left-1]
                left++;
            while left<right && num[right]==num[right+1]
                right--;
        else if >target
            right--;
        else left++
}
时间O(n^2)    空间O(n)





3Sum Closest (find three integers that sum is closest to a given number. Return the sum. Only one solution)
3Sum变体
初始化global_minDiff = num[0]+num[1]+num[2]-target
Arrays.sort(num);
for i=0; i<num.length-2; i++
    int diff = twoSum(num, i+1, -num[i]);
    if global_minDiff大 更新
return target+global_minDiff;

int twoSum(int[] num, int start, int target)
初始化minDiff
while(left<right)
    if ==target
        return;
    int localDiff = num[left]+num[right]-target;
    if minDiff大 更新
    if >target
        right--;
    else left++;





4Sum
仍是先对数组排序 从后往前扫一遍数组 对于非重复元素 调用3Sum subroutine后面跟3Sum一样 时间O(n^3)

此题还有一种解法可以达到O(n^2logn) 有时间看





Best Time to Buy and Sell Stock (一次交易的最大利润)
动态规划 局部解全局解
for i=1; i<prices.length; i++
    local = Math.max(local[i]+prices[i]-prices[i-1], 0);
    global = Math.max(global, local);

时间O(n) 空间O(1)





Best Time to Buy and Sell Stock ii (无限次交易的最大利润)
这题更简单 不限定交易次数那么只要差价大于0就可以一直累加 
for i=1; i<prices.length; i++
    if(prices[i]-prices[i-1]>0)
        maxProfit+=prices[i]-prices[i-1];
时间O(n) 空间O(1)





Best Time to Buy and Sell Stock iii (限定2次交易 扩展到k次)
local[i][j]=max(local[i-1][j]+diff, global[i-1][j-1]+max(diff,0)) 
global[i][j]=max(local[i][j],global[i-1][j])
for i=1; i<prices.length; i++
    int diff = prices[i]-prices[i-1];
    for(j=2; j>=1; j--)
        local[j] = Math.max(local[j]+diff, global[j-1]+Math.max(diff,0));
        global[j] = Math.max(local[j], global[j]);





Best Time to Buy and Sell Stock iv
ii iii结合





Combination Sum (找和为指定target的集合 每个元素可以用无限次)
NP问题
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0
for i=start; i<candidates.length; i++
    if(i>0 && candidates[i]==candidates[i-1])
        continue;
    item.add();
    helper(candidates, i, item, target-candidates[i], res);
    item.remove();





Combination Sum ii (每个元素只能用一次)
Arrays.sort(candidates);
helper(candidates, 0, new ArrayList<Integer>(), target, res);

if target==0
if target<0 || start==candidates.length;
for i=start; i<candidates.length; i++
    if i>start && candidates[i]==candidates[i-1]
        continue;
    item.add();
    helper(candidates, i+1, item, target-candidates[i], res);
    item.remove();

    



Subsets
递归
Arrays.sort(num);

private helper(int[] num, int index) {
    if(index==-1) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> tmp = new ArrayList<Integer>();
        res.add(tmp);
        return res;
    }
    List<List<Integer> res = helper(num, index-1);
    int size = res.size();
    for(int i=0; i<size; i++) {
        List<Integer> item = new ArrayLisT<Integer>(res.get(i));
        item.add(num[index]);
        res.add(item);
    }
    return res;
}

非递归
Arrays.sort(num);
List<list<Integer>> res = new ArrayList<List<Integer>>(new ArrayList<Integer>());
for(int i=0; i<num.length; i++) {
    int size - res.size();
    for(int j=0; j<size; j++) {
        List<Integer> item = new ArrayList<Integer>(res.get(j));
        item.add(num[i]);
        res.add(item);
    }    
}
return res;

时间O(2^n) 空集O(2^n)





Subsets ii
递归
Arrays.sort(num);

private helper(int[] num, int index, List<Integer> lastSize) {
    if(index==-1) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> tmp = new ArrayList<Integer>();
        res.add(tmp);
        return res;
    }
    List<List<Integer> res = helper(num, index-1);
    int size = res.size();
    int start = (index>0 && num[index]==num[index-1])? lastSize.get(0):0;
    for(int i=start; i<size; i++) {
        List<Integer> item = new ArrayLisT<Integer>(res.get(i));
        item.add(num[index]);
        res.add(item);
    }
    lastSize.set(0, size);
    return res;
}

非递归
Arrays.sort(num);
List<list<Integer>> res = new ArrayList<List<Integer>>(new ArrayList<Integer>());
int start = 0;
for(int i=0; i<num.length; i++) {
    int size - res.size();
    for(int j=start; j<size; j++) {
        List<Integer> item = new ArrayList<Integer>(res.get(j));
        item.add(num[i]);
        res.add(item);
    }
    if(i<num.length-1 && num[i]==num[i+1])
        start = size;
    else start = 0;    
}
return res;

时间O(2^n) 空集O(2^n)




Construct Binary Tree from Preorder and Inorder Traversal
树题 递归
HashMap<Integer, Integer> map 保存中序值和索引的对应关系
helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1, map);

TreeNode helepr() {
    if inL>inR || preL>preR
        return null;
    TreeNode root = new TreeNode(preorder[preL]);
    int index = map.get(preorder[preL]);
    root.left = 
    root.right = 
    return root;
}





Construct Binary Tree from Inorder and Postorder Traversal
同上





Container With Most Water
求两条垂直x轴的线和x轴围成的container里能乘的最大水量
while left<right
    int diff
    if diff>0
        int localWater = (right-left)*height[left];
        maxWater = maxWater<localWater ? localWater:maxWater;
        left++;
    else
        同上 right

时间O(n) 空间O(1)





Trapping Rain Water
上一题的进阶版 不是和x轴围 而是和中间其他高度围

两种解法 第一种扫两遍 先左扫一遍 再右扫一遍
for(int i=1; i<A.length-1; i++) {
    leftMax = Math.max(leftMax, A[i-1]);
    maxL[i] = leftMax;
}
int rightMax = 0;
for(int i=A.length-2; i>0; i--) {
    rightMax = Math.max(rightMax, A[i+1]);
    water+=Math.min(maxL[i], rightMax)>A[i]?Math.min(maxL[i], rightMax)-A[i]:0;
}

时间O(2*n)=O(n) 空间O(n)

第二种解法只需要扫一次数组 比较左右指针 取小的那边开始走 如果下一个元素更小就把差值加到结果中 否则重新比较左右指针大小 
while(left<right) {
    int minHeight = Math.min(A[left], A[right]);
    if(A[left]==minHeight) {
        left++;
        while(left<right && A[left]<=minHeight) {
            water+=minHeight-A[left];
            left++;
        }
    }
    else {
        right 同上
    }

时间O(n) 空间O(1)





Find Minimum in Rotated Array i (i假定没有重复元素 二有)
while left<right &&　num[left]>num[right]
    int mid = (left_right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else
        right = mid;
return num[left];

时间O(logn) 空间O(1)





Find Minimum in Rotated Array ii
while left<right
    int mid = (left+right)/2;
    if(num[mid]>num[right])
        left = mid + 1;
    else if(num[mid]<num[right])
        right = mid;
    else
        right--;
return num[left];

时间O(logn) 空间O(1)





Search in Rotated Sorted Array
while(left<=right)
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
时间O(logn) 空间O(1)





Search in Rotated Sorted Array ii
while left<=right
    if target==A[mid]
        return mid;
    if(A[mid]>A[right]) {
        if(A[left]<=target && target<A[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }
    else if(A[mid]<A[right]) {
        if(A[mid]<target && target<=A[right])
            left = mid + 1;
        else
            right = mid - 1;
    }
    else
        right--;
时间最坏是O(n) 空间O(1)





Search Insert Position
两种解法都可以
while(l<r) {
    int mid = (l+r)/2;
    if(A[mid]<target)
        l = mid + 1;
    else
        r = mid;
}
return A[l]<target? l+1:l;
时间O(logn) 空间O(1)

while(l<r) {
    int mid = (l+r)/2;
    if(A[mid]==target)
        return mid;
    else if(A[mid]<target)
        l = mid + 1;
    else
        r = mid - 1;
}
return l;
时间O(logn) 空间O(1)





Find Peak Element
还是二分法思路 
while(left<right) {
    int mid = (left+right)/2;
    if(num[mid]<num[mid+1])
        left = mid + 1;
    else
        right = mid;
}
return left;
时间O(logn) 空间O(1)





First Missing Positive integer
for i=0; i<A.length; i++
    if(A[i]>0 && A[i]<A.length+1 && A[A[i]-1]=A[i])
        int tmp = A[A[i]-1];
        A[A[i]-1] = A[i];
        A[i] = tmp;
        i--;
for i=0; i<A.length; i++
    if A[i]!=i+1;
        return i+1;
return A.length+1;

时间O(n) 空间O(1)





Merge Intervals
Comparator<Interval> cmp = new Comparator<Interval>(){
    public int compare(Interval i1, Interval i2) {
        if(i1.start==i2.start)
            return i1.end-i2.end;
        return i1.start-i2.start;
    }
};
Collections.sort(intervals, cmp);
for(int i=1; i<intervals.size(); i++)
    if(intervals.get(i).start<=intervals.get(i-1).end)
        intervals.get(i-1).end = Math.max(intervals.get(i-1).end, intervals.get(i).end);
        intervals.remove(i);
        i--;

时间O(n) 空间O(1)





Insert Intervals
这题是上一题的进阶版 
while(i<intervals.size() && intervals.get(i).end<newInterval.start)
    i++;
if(i<intervals.size());
    newInterval.start = Math.min(newInterval, intervals.get(i).start);
intervals.add(i, newInterval);
i++;
while(i<intervals.size() &&　newInterval.end>=intervals.get(i).start)
    newInterval.end = Math.max(newInterval.end, intervals.get(i).end);
    intervals.remove(i);

时间O(n) 空间O(1)





Jump Game
动态规划题
reach = 0
for i=0; i<A.length&&i<=reach; i++
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return false;
return true;

时间O(n) 空间O(1)





Jump Game ii
int step = 0, reach = 0, lastReach = 0;
for i=0; i<A.length&&i<=reach; i++
    if(i>lastReach)
        step++;
        lastReach = reach;
    reach = Math.max(reach, i+A[i]);
if(reach<A.length-1)
    return -1;
return step;

时间O(n) 空间O(1)





Largest Rectangle in Histogram
第一种做法对于每一个高度 分别往左右走找到它的最大面积 最后取所有最大面积中最大的 时间O(n^2) 空间O(1)

第二种做法 利用栈维护一个递增序列
for i=0; i<height.length; i++;
    if(stack.isEmpty() || height[i]>height[stack.peek()])
        stack.push(i);
    else {
        int currIndex = stack.pop();
        int width = stack.isEmpty()? i:i-stack.peek()-1;
        maxArea = Math.max(maxArea, width*height[i]);
        i--;
    }
while(!stack.isEmpty()) {
    int currIndex = stack.pop();
    int width = stack.isEmpty()? i:i-stack.peek()-1;
    maxArea = Math.max(maxArea, width*height[i]);
}

时间O(n) 空间O(n)





Maximal Rectangle
这题是上一题的扩展 
for int i=0; i<matrix.length; i++
    for int j=0; j<matrix[0].length; j++
        height[j] = matrix[i][j]=='0'? 0:height[j]+1;
    maxArea = Math.max(maxArea, largestRect(height));

时间上Largest Rectangle in Histogram的复杂度为O(n) 而计算一行高度的复杂度也为O(n) 所以每一行的复杂度是O(n+n)=O(n) 

总时间复杂度O(m*n) 空间上需要保存一行直方图的高度O(n)加上Largest Rectangle in Histogram所使用的空间O(n) 总空间复杂度还是O(n)





Longest Consecutive Sequence
1 先排序在统计最长连续子序列 时间O(nlogn)

2
HashSet<Integer> set 记录所有数

while(!set.isEmpty()) {
    Iterator i = set.iterator();
    int n = (int)i.next();
    set.remove(n);
    int left = n-1; l = 0;
    while(set.contains(left)) {
        l++;
        set.remove(left);
        left--;
    }
    right同left
    maxLen = Math.max(maxLen, l+1+r);
}

时间O(n) 空间O(n)





Majority Element
Moore voting algorithm
for i=0; i<num.length; i++
    if(count==0)
        major = num[i];
        count++;
    else if(major==num[i])
        count++;
    else count--;

时间O(n) 空间O(1)





Maximum Subarray
动态规划问题 递推式为 local[i+1] = Math.max(A[i+1], local[i]+A[i+1]), global[i+1] = Math.max(local[i+1], global[i])
int local = A[0], global = A[0];
for(int i=1; i<A.length; i++) {
    local = Math.max(local+A[i], A[i]);
    global = Math.max(global, local);
}

时间O(n) 空间O(1)





Maximum Product Subarray
int maxLocal = A[0], minLocal = A[0], maxCopy = A[0];
for(int i=1; i<A.length; i++) {
    int maxCopy = maxLocal;
    maxLocal = Math.max(maxLocal*A[i], Math.max(A[i], minLocal*A[i]));
    minLocal = Math.min(minLocal*A[i], Math.min(A[i], maxCopy*A[i]));
    global = Math.max(global, maxLocal);
}

时间O(n) 空间O(1)





Median of Two Sorted Arrays
if((A.length+B.length)%2==1)
else

private int helper(A, startA, endA, B, startB, endB, k) {
    lenA = endA-startA+1;
    lenB = endB-startB+1;
    if(lenA>lenB)
        return helper(B, startB, endB, A, startA, endA, k);
    if(k==1)
        return Math.min(A[startA], B[startB]);
    if(lenA==0)
        return B[startB+k-1];
    int posA = Math.min(k/2, lenA);
    int posB = k-posA;
    if(A[startA+posA-1]==B[startB+posB-1])
        return A[startA+posA-1];
    else if(A[startA+posA-1]>B[startB+posB-1])
        return helper(A, startA, startA+postA-1, B, startB+posB, endB, k-posB);
    else
        return helper(A, startA+posA, endA, B, startB, startB+posB+1, k-posA);
}

时间O(log(m+n)) 空间O(logk)





Merge Sorted Array
int indexA = m-1, indexB = n-1, index = m+n-1;
while(indexA>=0 && indexB>=0) {
    if(A[indexA]>B[indexB])
        A[index--] = A[indexA--];
    else
        A[index--] = B[indexB--];
}
while(indexB>=0)
    A[index--] = B[indexB--];

时间O(n) 空间O(1)





Unique Paths
动态规划 递推式为res[i][j] = res[i][j-1]+res[i-1][j]
res[0] = 1
for int i=0; i<m; i++
    for int j=1; j<n; j++
        res+=res[j-1]

时间O(m*n) 空间O(n)





Unique Paths ii
思路同上一题 只是这里有不能走的格子 递推式是若当前格子不为1则同上一题res[i][j]=res[i][j-1]+res[i-1][j] 否则res[i][j]=0 
res[0] = 1;
for i=0; i<obstacleGrid.length; i++
    for j=0; j<obstacleGrid[0].length; j++
        if(obstacleGrid[i][j]==1)
            res[j] = 0;
        else
            if(j>0)
                res[j]+=res[j-1];

时间O(m*n) 空间O(n)





Minimum Path Sum
带权重的最小路径和 如果是第一列元素res[j]=res[j-1]+grid[i][j] 否则res[j] = Math.min(res[j], res[j-1]) + grid[i][j] 
res[0] = grid[0][0];
for(int i=1; i<grid[0].length; i++)
    res[j] = res[j-1] + grid[0][i];
for i=1; i<grid.length; i++
    for j=0; j<grid[0].length; j++
        if(j==0)
            res[j]+=grid[i][0];
        else
            res[j] = grid[i][j]+Math.min(res[j], res[j-1]);

时间O(m*n) 空间O(n)





Missing Range
人为加两个元素在lower-1 upper+1可以避免所有pesky case
if A==null ||　A.length==0
    res.add(getRange(lower, upper));
int prev = lower-1;
for i=0; i<=A.length; i++
    int curr = (i==A.length)? upper+1:A[i];
    if curr-prev>=2
        res.add(getRange(prev+1, curr-1));
    prev = curr;

private String getRange(int from, int to)
    return (from==to)? String.valueOf(from):String.valueOf(from) + "->" + String.valueOf(to);

时间O(A.length) 空间O(1)





Next Permutation
int i=num.length-2;
while(i>=0 && num[i]>=num[i+1])
    i--;
if(i<0);
    reverse(num, 0);
    return;
int mark = i;
i = num.length-1;
while(num[i]<=num[mark])
    i--;
int tmp = num[mark];
num[mark] = num[i];
num[i] = tmp;
reverse(num, mark+1);

时间O(3*n)=O(n) 空间O(1)





Pascal Triangle
if rowNums<0
    return res;
List<Integer> first
first.add(1);
res.add(first);
for i=1; i<rowNums; i++
    List<Integer>　row = new ArrayList<Integer>()
    row.add(1);
    for j=1; j<i; j++
        row.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));
    row.add(1);
    res.add(row);

时间O(n^2) 空间O(1)





Pascal Triangle ii
List<Integer>　res
if(rowIndex<0)
    return res;
res.add(1);
for i=1; i<=rowIndex; i++
    for j=res.size()-1; j>=0; j--
        res.set(j, res.get(j)+res.get(j-1));
    res.add(1);

时间O(n^2) 空间O(1)





Triangle
动态规划题 递推式sum[i][j]=min(sum[i-1][j-1],sum[i-1][j])+triangle[i][j]
for i=1; i<triangle.size(); i++
    sum[i] = sum[i-1] + triangle.get(i).get(i);     
    for(int j=i-1; j>=1; j--) {                    
        sum[j] = sum[j]<sum[j-1]?sum[j]:sum[j-1] + triangle.get(i).get(j);
    }
    sum[0] += triangle.get(i).get(0);

时间O(n^2) 空间O(n)





Plus One
for i=digits.length-1; i>=0; i--
    if(digits[i]<9) {
        digits[i]+=1;
        return digits;
    }
    else
        digits[i] = 0;
int[] res
res[0] = 1;

时间O(n) 空间一般是O(1) 最坏为O(n)





Remove Duplicates from Sorted Array
index = 1
for i=1; i<A.length; i++
    if(A[i]!=A[index-1])
        A[index]=A[i];
        index++;
return index;

时间O(n) 空间O(1)





Remove Duplicates from Sorted Array ii
if A.length<3
    return A.length;
index = 2;
for i=2; i<A.length; i++
    if(A[i]!=A[index-2])
        A[index]=A[i];
        index++;
return index;
时间O(n) 空间O(1)





Remove Element
两种解法 思路差不多 从前往后扫 时间O(n) 空间O(1)
int j = A.length-1;
for(int i=0; i<=j; i++) {
    if(A[i]==elem)
        A[i--] = A[j--]; 
}

从后往前
int j = A.length-1;
for(int i=A.length-1; i>-1; i--)
{
    if(A[i]==elem)  
    {
        A[i] = A[j--];   
    }
}



Rotate Array
if(k<=0)return;
k = k%nums.length;
reverse(nums, 0, nums.length-1);
reverse(nums, 0, k-1);
reverse(nums, k, nums.length-1);
时间O(n) 空间O(1)





Rotate Image
矩阵相关操作 考察数组的操作 一层一层旋转 顺时针旋转和逆时针旋转90度差不多只是赋值不同 而旋转180度则为对应两行每次逆序交换数值
for(int layer=0; layer<matrix.length/2; layer++) {
    for(int i=layer; i<matrix.length-1-layer; i++) {
        int tmp = matrix[layer][i];
        matrix[layer][i] = matrix[matrix.length-1-i][layer];
        matrix[matrix.length-1-i][layer] = matrix[matrix.length-1-layer][matrix.length-1-i];
        matrix[matrix.length-1-layer][matrix.length-1-i] = matrix[i][matrix.length-1-layer];
        matrix[i][matrix.length-1-layer] = tmp;
    }
}

时间O(n^2) 空间O(1)





Search a 2D Matrix
while(l<=r)
    if(matrix[mid][0]==target)
        return true;
    else if(matrix[mid][0]>target)
        r = mid - 1;
    else l = mid +　１；
if(r<0)
    return false;
int row = l;
l = 0;
r = matrix[0].length-1;
while(l<=r)
    if(matrix[row][mid]==target)
        return true;
    else if 
    else
return false;
时间O(logn) 空间O(1)





Search for a Range
while(l<=r)
    if(A[mid]==target)
        break;
    else if
    else
if A[mid]!=target
    return res;
l = 0, r = mid
while l<=r
    if(A[mid]==target)
        r = mid -1;
    else l = mid + 1;
res[0] = l;
l = mid, r = A.length-1;
while l<=r
    if A[mid]==target
        l = mid　+ 1;
    else r = mid - 1;
res[1] = r;
时间O(logn) 空间O(1)







Set Matrix Zeroes
set rowMark
set colMark
for i=1; i<matrix.length; i++
    for j=1; j<matrix[0].length; j++
        if(matrix[i][j]==0)
            matrix[0][j]=0;
            matrix[i][0]=0;
for i=1; i<matrix.length; i++
    for j=1; j<matrix[0].length; j++
        if(matrix[0][j]==0 || matrix[i][0]==0)
            matrix[i][j]=0;
set first row col

时间O(m*n) 空间O(1)





Sort Colors
这题主要复习计数排序的思路 最好的思路是利用元素只有3种值的特点 扫一遍数组维护2个指针 一个将指向的数字变为1一个变味0 i将碰到的所有元素变为2 这样扫完一遍就

得到了结果 时间O(n) 空间O(1)



Spiral Matrix
while l<=r && up<=down
    if direction 0
        for i=l; i<=r; i++
            res.add(matrix[up][i])
        up++;
    if
    if
    if
    direction = (direction+1)%4;
时间O(m*n) 空间O(1)



Spiral Matrix ii
while l<=r && up<=down
    if direction 0
        for i=l; i<=r; i++
            res[up][i]=num;
            num++;
        up++;
    if
    if
    if
    direction = (direction+1)%4;
时间O(n*n) 空间O(1)





Word Search
图的思想 深度优先遍历 从某一点出发 如果当前元素是word中对应的字母 将当前字符标记为已访问继续递归上下左右四条边 如果最终长度等于word返回true 否则

如果坐标超出范围 或该字符已被访问过 或它不等于对应word中的字符返回false 如果从一个新的字符出发要重置访问标记 时间复杂度 空间O(m*n)































>>>>>>> f577b1f2d86f7991c70d64a63aead74e3fa827a4
















