Longest Substring Without Repeating Characters
窗口思想 维护一个窗口的左右边界 正常情况下右边界移动 并将遇到的字符放入一个HashSet中 当遇到重复字符时先更新maxLen 然后开始移动左边界直到左右指针 

指向同一个字符 过程中将遇到的字符从HashSet remove 最后左右指针各跳一位开始寻找新的长度 时间O(2*n)=O(n) 空间O(n)



Minimum Window Substring
窗口思想 先将所有子串的字符mapp到HashMap里 然后循环 右窗开始走碰到对应子串的字符就将其哈希表值减1 这里用一个count维护得到的子串长度 当所有子串字符都遇到了

count等于子串长度 开始走左窗口压缩 碰到子串的字符就把其哈希表值加1 当某个子串字符的值大于0 说明左窗口再走就凑不齐子串所有的字符了 计算一下当前长度如果小于

minLen就更新结果 这样当右窗口到达字符串尾部就得到最终结果 时间O(2*n)=O(n) 空间O(n)



Substring with Concatenation of All Words
窗口思路 先将所有单词都map到字典里 然后内外双循环 外层循环遍历L[0].length次 而内循环从0,1...L[0].length-1 每次右窗口以L[0].length为步长递增

每次取S的一个长度为L[0].length的substring 如果该字符串不在字典里 将当前字典清空 count重置为0 左窗口移动一个单词长 否则该字符串在字典中 

要更新当前循环的字典currMap 如果currMap里该字符串的value小于字典map里对应的值 就说明该字符串不是多余的重复单词 合法序列长度count++ 

否则如果是重复的单词则当前序列无法构成解(题目要求each word exactly once) 我们要移动左窗口 过程中将遇到的单词在currMap里的值更新 

如果某单词currMap里的值小于map的值了还要将count－1 当count等于L的元素个数时我们得到一个解将结果保存并移动左窗口以及更新currMap 从下一个单词位置开始继续

时间上每一个单词不会被访问超过2次一次左窗口一次右窗口所以是O(2*n/L*L)=O(n) 其中2*n为两次扫过字符床S的字符数 而每次循环以L[0].length为步长递增

所以要除以L 再加上外循环循环了L[0].length次 所以要乘以L 空间O(m*L)就是字典的长度



Longest Substring with At Most Two Distinct Characters
窗口思路 跟Longest Substring Without Repeating Characters差不多 这里我们用一个字典记录每一个字符出现的次数 正常情况下右窗口走 碰到新字符

count++ 否则只是更新其字典里对应的value 当count大于2时说明出现3个不同字符 此时移动有窗口无法得到更好结果要移动左窗口 将遇到的字符对应字典值

-1 如果某个字符字典值为0说明它已经不在系列里了 count-- 如此循环结束就可得到结果 时间O(n) 空间O(n)



Single Number
位运算思路 一般思路和Single Number ii一样 用一个整型数组digits统计元素出现次数 将数组中的数对应的位分别加到digits对应的元素中 统计完后对每一位取余3

结果中就只剩下出现一次的元素 时间O(n) 空间是32个元素的数组O(1) 另外这题可以用取巧的方法 对数组中每一个数做一次异或运算非常简单



Max Points on a Line
几何运算题 思路如下 1 外循环遍历所有点 2 内循环遍历i后所有的点 3 判断 相同点还是x或y相同或算斜率 4 更新map4 取本轮循环最大数＋numSame 

更新globalMax 时间O(n^2) 空间O(n)哈希表长度



Valid Sudoku
三次判断 依次判断同一行是否有重复数字 同一列是否有重复数 以及每个3*3的小格子里是否有重复数 每次对于非'.'的格子 用一个boolean[9]的数组标记已经

出现的数字 若有重复 则返回false否则继续判断 注意判断小格子对于列是用i=block/3*3 而对于行是用j=block%3*3 时间O(3*9^2)对于81个格子判断了3次



Sudoku Solver
NP问题 递归调用helper方法 如果当前格子为'.'则逐一试1到9九个数字如果是valid就递归下一个格子 isValid函数类似上一题只是这里不需要整个棋盘都判断

只需要判断当前行列和3*3的小格子就好 之前都已是valid 如果一行判断完跳到下一行return helper(board, i+1, 0) 当所有行都判断完就返回true