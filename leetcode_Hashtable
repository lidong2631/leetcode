Longest Substring Without Repeating Characters
窗口思想 维护一个窗口的左右边界 正常情况下右边界移动每次更新maxLen 并将遇到的字符放入一个256位的charMap中 当遇到重复字符移动左边界到重复字符的下一位 

过程中将遇到的字符置为false  时间O(2*n)=O(n) 空间O(n)

这题还有O(n)的解法只扫一遍 只是charMap中保存字符在字符串中的索引 维护左窗口i 每次比较如果charMap[s.charAt(j)]>=i 说明是重复字符 更新i 否则set

charMap[s.charAt(j)]=j并更新maxLen



Minimum Window Substring
窗口思想 先将所有子串的字符mapp到HashMap里 然后循环 右窗开始走碰到对应子串的字符就将其哈希表值减1 这里用一个count维护得到的子串长度 当所有子串字符都遇到了

count等于子串长度 开始走左窗口压缩 碰到子串的字符就把其哈希表值加1 当某个子串字符的值大于0 说明左窗口再走就凑不齐子串所有的字符了 计算一下当前长度如果小于

minLen就更新结果 这样当右窗口到达字符串尾部就得到最终结果 时间O(2*n)=O(n) 空间O(n)



Substring with Concatenation of All Words
窗口思路 先将所有单词都map到字典里 然后内外双循环 外层循环遍历L[0].length次 而内循环从0,1...L[0].length-1 每次右窗口以L[0].length为步长递增

每次取S的一个长度为L[0].length的substring 如果该字符串不在字典里 将当前字典清空 count重置为0 左窗口移动一个单词长 否则该字符串在字典中 

要更新当前循环的字典currMap 如果currMap里该字符串的value小于字典map里对应的值 就说明该字符串不是多余的重复单词 合法序列长度count++ 

否则如果是重复的单词则当前序列无法构成解(题目要求each word exactly once) 我们要移动左窗口 过程中将遇到的单词在currMap里的值更新 

如果某单词currMap里的值小于map的值了还要将count－1 当count等于L的元素个数时我们得到一个解将结果保存并移动左窗口以及更新currMap 从下一个单词位置开始继续

时间上每一个单词不会被访问超过2次一次左窗口一次右窗口所以是O(2*n/L*L)=O(n) 其中2*n为两次扫过字符床S的字符数 而每次循环以L[0].length为步长递增

所以要除以L 再加上外循环循环了L[0].length次 所以要乘以L 空间O(m*L)就是字典的长度



Longest Substring with At Most Two Distinct Characters
窗口思路 跟Longest Substring Without Repeating Characters差不多 这里我们用一个字典记录每一个字符出现的次数 正常情况下右窗口走 碰到新字符

numDistinct++ 否则只是更新其字典里对应的value 当numDistinct大于2时说明出现3个不同字符 此时移动有窗口无法得到更好结果要移动左窗口 将遇到的字符对应字典值

-1 如果某个字符字典值为0说明它已经不在系列里了 numDistinct-- 如此循环结束就可得到结果 时间O(n) 空间O(n)



Single Number
位运算思路 一般思路和Single Number ii一样 用一个整型数组digits统计元素出现次数 将数组中的数对应的位分别加到digits对应的元素中 统计完后对每一位取余3

结果中就只剩下出现一次的元素 时间O(n) 空间是32个元素的数组O(1) 另外这题可以用取巧的方法 对数组中每一个数做一次异或运算非常简单



Max Points on a Line
几何运算题 思路如下 1 外循环遍历所有点 2 内循环遍历i后所有的点 3 判断 相同点还是x或y相同或算斜率 4 更新map4 取本轮循环最大数＋numSame 

更新globalMax 时间O(n^2) 空间O(n)哈希表长度



Valid Sudoku
三次判断 依次判断同一行是否有重复数字 同一列是否有重复数 以及每个3*3的小格子里是否有重复数 每次对于非'.'的格子 用一个boolean[9]的数组标记已经

出现的数字 若有重复 则返回false否则继续判断 注意判断小格子对于列是用i=block/3*3 而对于行是用j=block%3*3 时间O(3*9^2)对于81个格子判断了3次



Sudoku Solver
NP问题 递归调用helper方法 如果当前格子为'.'则逐一试1到9九个数字如果是valid就递归下一个格子 isValid函数类似上一题只是这里不需要整个棋盘都判断

只需要判断当前行列和3*3的小格子就好 之前都已是valid 如果一行判断完跳到下一行return helper(board, i+1, 0) 当所有行都判断完就返回true



Anagrams
每次读一个字符串 排序 在Hashmap<String, List<String>>中找是否有对应key 没有就新建一个健值对 否则将这个词加到对应key的list里 
最后返回size大于1的list

即可 时间O(nklogk) 空间O(nk)



Binary Tree Inorder Traversal
三种方式 递归 迭代 Morris 时间都是O(n) 空间分别为O(logn) O(logn) O(1)



Copy List with Random Pointer
两种解法 第一种利用哈希表 扫一遍链表每次复制对应节点并将原始节点和新建节点放入哈希表 再扫一遍链表利用哈希表的信息copy random指针

第二种解法扫三遍链表 第一遍将每个节点copy一份放在节点后面 第二遍扫复制random指针 具体为curr.next.random = curr.random.next 第三遍拆分

第二种解法空间为O(1) 




















