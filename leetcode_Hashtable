Longest Substring Without Repeating Characters
窗口思路 如果是ASCII
1
用一个256 boolean数组标记是否重复
for i=0； i<S.length(); i++
	while exists[S.charAt(i)] 只要重复字符
		exists[j] = false
		j++;
	exists[i] = true 不是重复 设为true
	maxLen = Math.max(maxLen, i-j+1);
return maxLen

2
上一种解法要扫两遍 可以只扫一遍 数组不标记是否重复 而是存字符的索引
int charMap[] = new int[256];
Arrays.fill(charMap, -1);
int j=0;
for i=0; i<S.length(); i++
	if charMap[S.charAt(i)]>=j 重复字符出现
		j = charMap[S.charAt(i)]+1; j跳到这个字符的下一位
	charMap[S.charAt(i)] = j;	非重复就更新charMap
	更新maxLen
return maxLen

如果不是ASCII 就要用set替代256数组 

时间O(n) 空间O(1) 如果用set就要O(n)





Longest Substring with At Most Two Distinct Characters
for i=0; i<s.length(); i++
	if(count[s.charAt(j)]==0)  
        numDistinct++;
    count[s.charAt(j)]++;
    while(numDistinct>2) {  
        count[s.charAt(i)]--;
        if(count[s.charAt(i)]==0)
            numDistinct--;
        i++;
    }
    maxLen = Math.max(maxLen, j-i+1);
}
return maxLen;

时间O(2*n) 空间O(1)




Minimum Window Substring
窗口思路
HashMap<Character, Integer> map 记录T中每个字符出现的次数
for T
	map初始化赋值
for i=0; i<S.length(); i++
	if map中有这个字符
		map中对应值-1
		if 减完后map中对应值>=0 则这个不是重复多余字符
			count要加1
		while count等于T的长度 可以左移窗口
			if map包含这个字符
				更新map中的值
				if 更新map值后>0 则压缩到头
					if 得到这个结果 i-leftP+1<minLen
						更新minLen和结果
					count--因为有效字符被移除一个
			leftP++
return res

时间O(n) 空间O(T)





Substring with Concatenation of All Words
窗口思路
HashMap<String, Integer> map 记录L中对应单词出现次数
for T
	map初始化赋值
for i=0; i<L[0].length(); i++ 外循环
	HashMap<String, Integer> currMap 记录当前得到的字典中的单词的出现次数
	int count = 0, left = i; count记录当前循环已得到的字典中词的个数
	for j=i; j<=S.length()-L[0].length(); j+=L[0].length()		内循环
		拿到当前字符串currStr = S.substring(j, j+L[0].length());
		if map中有currStr	
			更新currMap中的值 if currMap.get(currStr)+1
							  else	currMap.put(currStr, 1)
			if currMap中的值<=Map中的值
				count++
			else
				while currMap中的值>Map中的值 就要一直左移窗口直到把这个多余字符去掉
					拿到left指的单词tmpstr = S.substring(left, left+L[0].length()) 将tmpStr在currMap中的值-1 更新count left右移一个单词
			if count等于L长度
				找到一个解 加入结果 更新currMap count 右移left
		else map中没有
			count=0 清空currMap left右移到j+L[0].length()

时间O(2*n/L) 每一次循环最多左右窗口各扫一次 一共L次所以总时间为O(2*n/L*L)=O(n) 空间O(m*L)






Single Number i ii



Max Points on a Line
几何运算题 思路如下 1 外循环遍历所有点 2 内循环遍历i后所有的点 3 判断 相同点还是x或y相同或算斜率 4 更新map4 取本轮循环最大数＋numSame 

更新globalMax 时间O(n^2) 空间O(n)哈希表长度



Valid Sudoku
三次判断 依次判断同一行是否有重复数字 同一列是否有重复数 以及每个3*3的小格子里是否有重复数 每次对于非'.'的格子 用一个boolean[9]的数组标记已经

出现的数字 若有重复 则返回false否则继续判断 注意判断小格子对于列是用i=block/3*3 而对于行是用j=block%3*3 时间O(3*9^2)对于81个格子判断了3次



Sudoku Solver
NP问题 递归调用helper方法 如果当前格子为'.'则逐一试1到9九个数字如果是valid就递归下一个格子 isValid函数类似上一题只是这里不需要整个棋盘都判断

只需要判断当前行列和3*3的小格子就好 之前都已是valid 如果一行判断完跳到下一行return helper(board, i+1, 0) 当所有行都判断完就返回true



Anagrams
每次读一个字符串 排序 在Hashmap<String, List<String>>中找是否有对应key 没有就新建一个健值对 否则将这个词加到对应key的list里 
最后返回size大于1的list

即可 时间O(nklogk) 空间O(nk)



Binary Tree Inorder Traversal
三种方式 递归 迭代 Morris 时间都是O(n) 空间分别为O(logn) O(logn) O(1)



Copy List with Random Pointer
两种解法 第一种利用哈希表 扫一遍链表每次复制对应节点并将原始节点和新建节点放入哈希表 再扫一遍链表利用哈希表的信息copy random指针

第二种解法扫三遍链表 第一遍将每个节点copy一份放在节点后面 第二遍扫复制random指针 具体为curr.next.random = curr.random.next 第三遍拆分

第二种解法空间为O(1) 




















