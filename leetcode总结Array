Array

Two Sum (注意:题目假设只有一个解)
两种方法 第一种用HashMap 遍历一遍数组 如果target-number[i]没出现在表中 就将number[i]放在表中 否则找到结果输出 时间O(n) 空间O(n)

第二种先排序然后两边夹逼 这种比较好应付不只有一个解的情况 不过这题要求输出数字的index而不是数字本身 所以要多开一个HashMap纪录数字原始的index

所以时间O(nlogn＋n)=O(nlogn) 空间O(n)



Two Sum ii - input array is sorted
这题假设数组已排好序 可以直接用两边夹逼的方法做出 时间O(n) 空间O(n)



3Sum (数组中可能有重复值)
这题先对数组排序这样处理重复值会比较方便 然后遍历一遍数组每次取一个数 调用Two Sum的subroutine找两个数和为-num[i] 注意这里循环要从后往前走

不然输出就不是从小到大输出OJ过不了 时间O(n^2+nlogn)=O(n^2) 空间O(n)

这题要注意去重有两个地方一个是主循环中if(i<num.length-1 && num[i]==num[i+1])去除取第一个数时的重复

另一个是TwoSum里while(left<right && num[left]==num[left-1]) while(left<right && num[right]==num[right+1])去除取TwoSum时的重复



3Sum Closest (find three integers that sum is closest to a given number. Return the sum. Only one solution)
3Sum变体 一样是先排序数组 设closest起始为num[0]+num[1]+num[2]-target 从前往后遍历一遍数组仍然是调用TwoSum找两个数和最接近target-num[i]

如果出来的结果的绝对值小于closest更新closest 最后输出closest+target 注意TwoSum中稍有变化 每次从左右取两个数减target得到localDiff

跟diff比较如果localDiff小就更新diff 然后根据num[left]+num[right]的值继续夹逼target 如果是0就直接返回



4Sum
仍是先对数组排序 从后往前扫一遍数组 对于非重复元素 调用3Sum subroutine后面跟3Sum一样 时间O(n^3)

此题还有一种解法可以达到O(n^2logn) 有时间看



Best Time to Buy and Sell Stock (一次交易的最大利润)
动态规划 局部解全局解 维护两个量 global到目前为止最好的利润 local在当前天卖出最好的利润 local = Math.max(local+prices[i+1]-prices[i], 0)

也就是知道第i天卖出的最大利润 加上i＋1天与i天的差价 如果这个差价加上i天的最大利润比0还小就是0 代表当天买当天卖 global = Math.max(local, global)

时间O(n) 空间O(1)



Best Time to Buy and Sell Stock ii (无限次交易的最大利润)
这题更简单 不限定交易次数那么只要差价大于0就可以一直累加 时间O(n) 空间O(1)



Best Time to Buy and Sell Stock iii (限定2次交易 扩展到k次)
难题 维护两个量 global[j]到达第i天最多可以进行j次交易可以获得的最大利润 local[j]到达第i天最多进行j次交易并且最后一次交易在第i天发生的最好利润

local[i][j]=max(local[i-1][j]+diff, global[i-1][j-1]+max(diff,0)) 第一个取local第i-1天j次交易，然后加上今天的差值

(这里因为local[i-1][j]包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，否则就不满足local[i][j]必须在最后一天卖出的条件了）

第二个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天）

global[i][j]=max(local[i][j],global[i-1][j])



Combination Sum (找和为指定target的集合 每个元素可以用无限次)
NP问题 先排序好处理重复元素 然后丢给helper helper中判断如果target<0返回 target=0找到一组解放到res中 否则循环 注意循环先要判断重复元素因为元素可以无限使用

若前面已用过这个元素 后面再出现就可以直接跳过 每次递归调用helper时start仍是i因为元素可以多次使用



Combination Sum ii (每个元素只能用一次)
跟上一题类似 只是递归helper时start值为i＋1因为元素只能用一次 而上一题start仍是i 另外这一题还是递归前还是要判断重复元素 因为虽然一个元素不可以重复使用

但一个元素重复出现多次是允许的 为了避免出现重复结果集只对第一次碰到这个数递归 接下来再碰到就直接跳过



Construct Binary Tree from Preorder and Inorder Traversal
树的难题 先用HashMap保存中序遍历的下标以便后面寻找根的下标 然后仍然是用helper递归 这里利用先序遍历找到根的下标 然后递归左右子树

这里麻烦在递归先序的下标 中序比较好处理 root.left = helper(preorder, preStart+1, preStart+index-inStart, inorder, inStart, index-1, map);
                                                        根后一位就是左子树开始位置   左子树结束位置 index-inStart是先序左子树加根的长度
root.right = helper(preorder, preStart+1+index-inStart, preEnd, inorder, index+1, inEnd, map);
                                右子树开始位置 左子树结束位置＋1


例子 先序遍历是12453687 中序遍历是42516837 后序遍历是45286731
                    1
            2               3
        4       5       6       7
                          8


Construct Binary Tree from Inorder and Postorder Traversal
同上一题 递归后序的下标为 root.left = helper(inorder, inStart, index-1, postorder, postStart, postStart+(index-inStart)-1, map);
                                                                                            左子树结束位置
root.right = helper(inorder, index+1, inEnd, postorder, postEnd-(inEnd-index), postEnd-1, map);
                                                        从根往前右子树长度位        根－1是右子树结束位置



<<<<<<< HEAD













=======
Container With Most Water
类似TwoSum中的夹逼法 每次迭代比较左右指针谁指的数小 小的那个就是瓶颈 谁小就继续移动谁 维护最大盛水量 这样扫一遍数组后可以得到结果

时间O(n) 空间O(1)



Find Minimum in Rotated Array i ii (i假定没有重复元素 二有)
这题i ii用一种解法都可以搞定 参见ii的第一种解法 可以处理有重复和没重复元素的情况 本质也是二分查找 只是不是找指定target而是找最小值

这道题要留意的是下标总是会偏向左 所以在二分时变化是right = mid; left = mid+1要特别体会这点 另外这题ii多加的重复条件会影响复杂度要注意

原先搜索某一个元素，所以可以夹逼到找到元素或者他们交错为止，现在的主要问题是如果l和r相差1以内，那么m就会等于l，如此下面的条件就会跳过r，

而最小元素可能就在r里面，所以终止条件才改成l<r-1使得夹逼就停止在最后两个元素中



Find Peak Element
还是二分法思路 如果num[mid]>num[mid+1] right=mid; else left=mid+1 下标的处理跟Find Minimum一样 

就剩两个元素比较时 指针一定落在左边的元素 所以mid+1不会越界 时间O(n) 空间O(1)



First Missing Positive integer
思路是找第一个违反A[A[i]-1]=A[i]的元素 遍历一遍数组A 对于A[i]>0&&A[i]<=A.length&&A[A[i]-1]!=A[i]的元素进行交换

交换code为
int tmp = A[A[i]-1]; 
A[A[i]-1] = A[i]; 
A[i]=tmp; 
i--;

注意第一个判断最后一个条件不能用A[i]!=i+1 只能用A[A[i]-1]!=A[i] 否则碰到重复元素会死循环 就是不停交换两个相同的元素 而用A[A[i]-1]!=A[i]

做判断条件好处是它只检查A[A[i]-1]放的值是不是应放的值A[i]跟当前下标i无关 扫完一遍后再扫一次数组找到第一个不符合规律的数即是结果 如果都符合

就是A.length+1



Merge Intervals
先对interval排序 然后扫一遍interval 如果当前interval和结果集中最后一个有重叠 就把结果集中最后一个元素的end设为它和当起interval的end中较大值

否则直接将当前interval加到结果集中

排序要用到Comparator接口 具体如下
Comparator<Interval> comp = new Comparator<Interval>()  
{  
    @Override  
    public int compare(Interval i1, Interval i2)  
    {  
        if(i1.start==i2.start)  
            return i1.end-i2.end;  
        return i1.start-i2.start;  
    }  
};  
Collections.sort(intervals,comp);  
>>>>>>> e1726386107db545bdcfa0e769c3d529b5cda120

时间O(n) 空间O(1)


Insert Intervals
这题是上一题的进阶版 先扫一遍list找到newInterval.start<intervals.get(i).end 如果有这个interval就先将newInterval.start和intervals.get(i).start

merge 然后将newInterval插入位置i i++跳到下一个位置 从i开始往后扫 只要newInterval.end跟当前interval.get(i)有交集 就将它合并进newInterval

并从原list中remove这个interval 时间O(n) 空间O(1)



Jump Game
动态规划题 维护一个到目前为止能跳到的最远距离reach 循环扫一遍数组 对于每一步更新reach=Math.max(reach, A[i]+i) 只要i<=reach就可以一直循环

最后跳出循环判断reach>=A.length-1说明可以完成 否则返回false 时间O(n) 空间O(1)



Jump Game ii
上一题的扩展 只是这里要多维护两个量 一个上一次能跳到的最大距离lastReach和最小步数step 只要lastReach大于等于i就不需要多走一步 否则step+1

更新lastReach=reach reach跟上一题一样还是每次都更新 循环后如果reach<A.length-1说明跳不过去返回0 否则返回step



Largest Rectangle in Histogram
维护一个栈 栈里的元素是递增的 扫一遍数组如果当前元素小于栈顶元素那么就一直出栈直到栈顶元素小于当前元素 在这个过程中计算每个矩阵的面积 关键代码如下
peekIndex = stack.pop();
int width = stack.isEmpty()?i:i-stack.peek()-1;
maxArea = Math.max(maxArea, width*height[peekIndex]);

最后循环结束还要检查下栈是否为空 不为空要将元素都弹出计算面积 时间O(n) 空间最坏O(n)



Maximal Rectangle
这题是上一题的扩展 求0-1矩阵面积最大的全1矩阵 对于矩阵每一行可以用上一题的routine来求出最大面积 一共有m行所以要调m次 在计算的过程中只需要维护上一行

的高度就可以了 如果下一行对应元素为0则高度是0 否则时上一行高度加1 这样在线性时间里就可以完成对高度的更新 Largest Rectangle in Histogram的复杂度

为O(n) 而计算一行高度的复杂度也为O(n) 所以每一行的复杂度是O(n+n)=O(n) 总时间复杂度O(m*n) 空间上需要保存一行直方图的高度O(n)加上Largest Rectangle

in Histogram所使用的空间O(n) 总空间复杂度还是O(n)



Longest Consecutive Sequence
这题借用了图的思想 将每个元素看作图的一个顶点 相邻的数就是它的边 做一次深度优先遍历 找出当前元素的最大连续子串过程中移除用过的元素

实现上先将所有元素放入一个HashSet 只要set不空就一直循环 每次从set中取出一个元素 找它相邻左右的元素是否在set中 在就将长度＋1并将此元素从set中移除

最后更新最大长度 退出循环时返回最大长度即可



Majority Element
Moore voting algorithm 扫一遍数组 维护一个count和一个curr变量 如果相同变量count＋1 否则count－1 如果count为0 则更新curr为num[i] 因为存在

大于半数的元素 所以这样累加抵消的最终结果一定是那个大于半数的数 时间O(n) 空间O(1)



Maximum Subarray
经典动态规划问题 局部解全局解 递推式为 local[i+1] = Math.max(A[i+1], local[i]+A[i+1]), global[i+1] = Math.max(local[i+1], global[i])

时间O(n) 空间O(1)



Maximum Product Subarray
还是局部最优全局最优 只是要多维护一个当前最小值 因为乘法的特性 现在很小的值可以和后面负数产生最大值 其他跟Maximum Subarray那题差不多



Median of Two Sorted Arrays
求两个有序数组的中位数 时间要在log(m+n) k初始为A B数组长度的一半 每次两个数组各取第k/2号元素 比较大小 如果A小就把A[k/2]以前的元素都剔除掉 如果B小就把

B[k/2]以前的元素都剔除掉 相等就直接返回 这样每次都能删除k/2个元素 当k最终等于1时返回Math.min(A[startA], B[startB]) 或若最终A的长度为0就返回

B[startB+k-1] 时间O(log(m+n)) 空间O(log(m+n))



Merge Sorted Array
因为A has enough space所以从A的m+n-1个元素开始 比较A[m-1]和B[n-1]将大的值放入A[m+n-1] 如此循环直到一个数组为空 之后如果B中还有元素依次放入A

A中元素已经就位不用管了 时间O(n) 空间O(1)



Unique Paths
动态规划 递推式为res[i][j] = res[i][j-1]+res[i-1][j] 维护一个列大小的一维数组 从第一行开始扫 每次更新res[j]+=res[j-1] 最后返回res[n-1]

时间O(m*n) 空间O(n)



Unique Paths ii
思路同上一题 只是这里有不能走的格子 递推式是若当前格子不为1则同上一题res[i][j]=res[i][j-1]+res[i-1][j] 否则res[i][j]=0 还是从第一行开始扫

每次判断一下当前格子是否为1 然后用对应递推式更新即可 时间O(m*n) 空间O(n)



Minimum Path Sum
跟Unique Paths系列差不多 只是这次每个格子有值相当于有权重 仍然是用一维数组 首先给数组赋初值将第一行每个元素的累加值放到对应数组元素中 然后从第二行开始

更新res的值 如果是第一列元素res[j]+=grid[i][j] 否则res[j] = Math.min(res[j], res[j-1]) + grid[i][j] 时间O(m*n) 空间O(n)



Next Permutation
从后往前扫一遍数组 找到第一个违反递增顺序的元素 如果不存在返回最大的序列 否则再从这个元素往后扫找到比它大的数中最小的那个交换他们的位置 在就将

他们交换位置 并把后面的元素reverse即可 最坏要扫三次 时间O(3*n)=O(n) 空间O(1)



Pascal Triangle
根据行数创建杨辉三角 思路很简单 先创建第一行 然后从第二行开始循环  时间O(n^2) 空间O(1)



Pascal Triangle ii
求k行的杨辉三角 比上一题还容易 时间O(n^2) 空间O(1)



Plus One
循环加1操作 每次更新digits[i]和carry 如果carry不为0就一直循环 为0则返回结果 最后如果还有进位则要新建一个长度为digits.length+1数组 

将头元素设为1 时间O(n) 空间一般是O(1) 最坏为O(n)



Remove Duplicates from Sorted Array
设index为1 从数组第二个元素开始扫 每次比较index-1和i指向的元素是否相等 若相等A[index]=A[i] index++ 否则进入下一次循环 最后返回index即可

时间O(n) 空间O(1)



Remove Duplicates from Sorted Array ii
跟上题思路类似 只是可以重复一次 设index为2 从数组第三个元素开始扫 比较index-2和i指向的元素是否相等 若相等A[index]=A[i] index++ 

否则进入下一次循环 时间O(n) 空间O(1)



Remove Element
两种解法 思路差不多 从前往后扫 时间O(n) 空间O(1)
for(int i=0; i<=len; i++) {
    if(A[i]==elem)
        A[i--] = A[len--]; 
}

从后往前
for(int i=A.length-1; i>-1; i--)
{
    if(A[i]==elem)  
    {
        A[i] = A[j--];   
    }
}



Rotate Array
思路比较简单 先反转整个数组 然后
















